<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>权译&#39;s  Blog</title>
  
  <subtitle>记录生活点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/DJoeyZhang/"/>
  <updated>2021-06-21T04:10:01.165Z</updated>
  <id>https://github.com/DJoeyZhang/</id>
  
  <author>
    <name>权译</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Web开发的一些面试题</title>
    <link href="https://github.com/DJoeyZhang/archives/7f76ef76.html"/>
    <id>https://github.com/DJoeyZhang/archives/7f76ef76.html</id>
    <published>2021-06-18T06:47:40.000Z</published>
    <updated>2021-06-21T04:10:01.165Z</updated>
    
    <content type="html"><![CDATA[<p>这次记一些面试题总结，给自己用。<br><br><a id="more"></a><br>一、Vue and React<br><br>1、Vue底层原理<br><br>基于MVVM设计，双向绑定:发布者－订阅者模式,Object.defineProperty()数据劫持。<br><a href="https://www.jianshu.com/p/5990a386132a" target="_blank" rel="noopener">https://www.jianshu.com/p/5990a386132a</a></p><p>2、webpack一些配置，删除无用代码原理，chunk如何加载，摇树，runtime<br><br>通过分析静态的ES模块，来剔除未使用代码的。<br><br>webpack –config webpack.config.js<br><br>chunk动态加载：<a href="https://www.cnblogs.com/dahe1989/p/11543832.html" target="_blank" rel="noopener">https://www.cnblogs.com/dahe1989/p/11543832.html</a><br><br>webpack打包去除无用代码：<a href="https://www.cnblogs.com/maycpou/p/14560116.html" target="_blank" rel="noopener">https://www.cnblogs.com/maycpou/p/14560116.html</a></p><p>3、手写promise<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">class WPromise &#123;</span><br><span class="line">    static pending = &apos;pending&apos;;</span><br><span class="line">    static fulfilled = &apos;fulfilled&apos;;</span><br><span class="line">    static rejected = &apos;rejected&apos;;</span><br><span class="line"></span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        this.status = WPromise.pending; // 初始化状态为pending</span><br><span class="line">        this.value = undefined; // 存储 this._resolve 即操作成功 返回的值</span><br><span class="line">        this.reason = undefined; // 存储 this._reject 即操作失败 返回的值</span><br><span class="line">        // 存储then中传入的参数</span><br><span class="line">        // 至于为什么是数组呢？因为同一个Promise的then方法可以调用多次</span><br><span class="line">        this.callbacks = [];</span><br><span class="line">        executor(this._resolve.bind(this), this._reject.bind(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // onFulfilled 是成功时执行的函数</span><br><span class="line">    // onRejected 是失败时执行的函数</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        // 返回一个新的Promise</span><br><span class="line">        return new WPromise((nextResolve, nextReject) =&gt; &#123;</span><br><span class="line">            // 这里之所以把下一个Promsie的resolve函数和reject函数也存在callback中</span><br><span class="line">            // 是为了将onFulfilled的执行结果通过nextResolve传入到下一个Promise作为它的value值</span><br><span class="line">            this._handler(&#123;</span><br><span class="line">                nextResolve,</span><br><span class="line">                nextReject,</span><br><span class="line">                onFulfilled,</span><br><span class="line">                onRejected</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _resolve(value) &#123;</span><br><span class="line">        // 处理onFulfilled执行结果是一个Promise时的情况</span><br><span class="line">        // 这里可能理解起来有点困难</span><br><span class="line">        // 当value instanof WPromise时，说明当前Promise肯定不会是第一个Promise</span><br><span class="line">        // 而是后续then方法返回的Promise（第二个Promise）</span><br><span class="line">        // 我们要获取的是value中的value值（有点绕，value是个promise时，那么内部存有个value的变量）</span><br><span class="line">        // 怎样将value的value值获取到呢，可以将传递一个函数作为value.then的onFulfilled参数</span><br><span class="line">        // 那么在value的内部则会执行这个函数，我们只需要将当前Promise的value值赋值为value的value即可</span><br><span class="line">        if (value instanceof WPromise) &#123;</span><br><span class="line">            value.then(</span><br><span class="line">                this._resolve.bind(this),</span><br><span class="line">                this._reject.bind(this)</span><br><span class="line">            );</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.value = value;</span><br><span class="line">        this.status = WPromise.fulfilled; // 将状态设置为成功</span><br><span class="line"></span><br><span class="line">        // 通知事件执行</span><br><span class="line">        this.callbacks.forEach(cb =&gt; this._handler(cb));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _reject(reason) &#123;</span><br><span class="line">        if (reason instanceof WPromise) &#123;</span><br><span class="line">            reason.then(</span><br><span class="line">                this._resolve.bind(this),</span><br><span class="line">                this._reject.bind(this)</span><br><span class="line">            );</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.reason = reason;</span><br><span class="line">        this.status = WPromise.rejected; // 将状态设置为失败</span><br><span class="line"></span><br><span class="line">        this.callbacks.forEach(cb =&gt; this._handler(cb));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _handler(callback) &#123;</span><br><span class="line">        const &#123;</span><br><span class="line">            onFulfilled,</span><br><span class="line">            onRejected,</span><br><span class="line">            nextResolve,</span><br><span class="line">            nextReject</span><br><span class="line">        &#125; = callback;</span><br><span class="line"></span><br><span class="line">        if (this.status === WPromise.pending) &#123;</span><br><span class="line">            this.callbacks.push(callback);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.status === WPromise.fulfilled) &#123;</span><br><span class="line">            // 传入存储的值</span><br><span class="line">            // 未传入onFulfilled时，value传入</span><br><span class="line">            const nextValue = onFulfilled</span><br><span class="line">                ? onFulfilled(this.value)</span><br><span class="line">                : this.value;</span><br><span class="line">            nextResolve(nextValue);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.status === WPromise.rejected) &#123;</span><br><span class="line">            // 传入存储的错误信息</span><br><span class="line">            // 同样的处理</span><br><span class="line">            const nextReason = onRejected</span><br><span class="line">                ? onRejected(this.reason)</span><br><span class="line">                : this.reason;</span><br><span class="line">            nextReject(nextReason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、封装fetch<br><br>接上一个Promise实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 模拟一个简单的异步行为 */</span><br><span class="line">function fetchData() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&apos;willem&apos;);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetchData().then((data) =&gt; &#123;</span><br><span class="line">    // after 1000ms</span><br><span class="line">    console.log(data); // willem</span><br><span class="line">    return &apos;wei&apos;;</span><br><span class="line">&#125;, (err) =&gt; &#123;&#125;).then((data2) =&gt; &#123;</span><br><span class="line">    console.log(data2); // wei</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>5、es6转es5原理<br><br>(1)parse<br><br>第一步主要是将 ES6 语法解析为 AST 抽象语法树。简单地说就是将代码打散成颗粒组装的对象。这一步主要是通过 babylon 插件来完成<br><br>(2)transfrom<br><br>第二步是将打散的 AST 语法通过配置好的 plugins（babel-traverse 对 AST 进行遍历转译）和 presets （es2015 / es2016 / es2017 / env / stage-0 / stage-4 其中 es20xx 表示转换成该年份批准的标准，env 是最新标准，stage-0 和 stage-4 是实验版）转换成新的 AST 语法。这一步主要是由 babel-transform 插件完成。plugins 和 presets 通常在 .babelrc 文件中配置。<br><br>(3)Generator<br><br>第三步是将新的 AST 语法树对象再生成浏览器都可以识别的 ES5 语法。这一步主要是由 babel-generator 插件完成。<br><br><a href="https://blog.csdn.net/weixin_44135121/article/details/104161852" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44135121/article/details/104161852</a></p><p>6、手写函数curry,闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 普通的add函数</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Currying后</span><br><span class="line">function curryingAdd(x) &#123;</span><br><span class="line">    return function (y) &#123;</span><br><span class="line">        return x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 2)           // 3</span><br><span class="line">curryingAdd(1)(2)   // 3</span><br></pre></td></tr></table></figure></p><p>curry：<a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">https://www.jianshu.com/p/2975c25e4d71</a><br><br>闭包：<a href="https://www.jianshu.com/p/9eb30b6af3a1" target="_blank" rel="noopener">https://www.jianshu.com/p/9eb30b6af3a1</a></p><p>7、手写前序遍历、中序遍历、快排<br><br><a href="https://www.cnblogs.com/echolun/p/13328927.html" target="_blank" rel="noopener">https://www.cnblogs.com/echolun/p/13328927.html</a></p><p>8、vue路由原理，路由守卫<br><br>路由原理：<a href="https://www.cnblogs.com/gaosirs/p/10606266.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaosirs/p/10606266.html</a><br><br>路由守卫：<a href="https://www.jianshu.com/p/691379025334" target="_blank" rel="noopener">https://www.jianshu.com/p/691379025334</a></p><p>9、react hook相关<br><br><a href="https://blog.csdn.net/kellywong/article/details/106430977" target="_blank" rel="noopener">https://blog.csdn.net/kellywong/article/details/106430977</a></p><p>10、如何优化，前端错误监控<br><br>数据采集-&gt;上报-&gt;服务处理-&gt;数据存储-&gt;可视化<br><br><a href="https://segmentfault.com/a/1190000021029136" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021029136</a></p><p>11、vue和react框架比较<br><br>二者都通过虚拟DOM，在渲染之前进行domDiff操作，降低了dom 频繁操作的成本，<br><br>vue 的模版语法对初学者较容易上手<br></p><p>12、webpack进行css-less打包<br><br><a href="https://www.jianshu.com/p/218ecf81c07b" target="_blank" rel="noopener">https://www.jianshu.com/p/218ecf81c07b</a></p><p>二、浏览器相关<br><br>1、浏览器存储方式有什么<br><br>Cookie、localStorage、 sessionStorage<br><br><a href="https://www.cnblogs.com/jing-tian/p/10991431.html" target="_blank" rel="noopener">https://www.cnblogs.com/jing-tian/p/10991431.html</a></p><p>2、LS的limit一般浏览器限制多少<br><br>5M,cookie较小，一般4k<br></p><p>3、如果LS做缓存层有什么方案保证不溢出<br><br>LRU</p><p>4、LRU实现<br><br><a href="https://www.cnblogs.com/everlose/p/12854807.html" target="_blank" rel="noopener">https://www.cnblogs.com/everlose/p/12854807.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var LRUCache = function (capacity) &#123;</span><br><span class="line">  this.cache = new Map();</span><br><span class="line">  this.capacity = capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.get = function (key) &#123;</span><br><span class="line">  if (this.cache.has(key)) &#123;</span><br><span class="line">    // 存在即更新</span><br><span class="line">    let temp = this.cache.get(key);</span><br><span class="line">    this.cache.delete(key);</span><br><span class="line">    this.cache.set(key, temp);</span><br><span class="line">    return temp;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.put = function (key, value) &#123;</span><br><span class="line">  if (this.cache.has(key)) &#123;</span><br><span class="line">    // 存在即更新（删除后加入）</span><br><span class="line">    this.cache.delete(key);</span><br><span class="line">  &#125; else if (this.cache.size &gt;= this.capacity) &#123;</span><br><span class="line">    // 不存在即加入</span><br><span class="line">    // 缓存超过最大值，则移除最近没有使用的</span><br><span class="line">    this.cache.delete(this.cache.keys().next().value);</span><br><span class="line">  &#125;</span><br><span class="line">  this.cache.set(key, value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>5、浏览器输入url到页面呈现过程<br><br>DNS 解析 -&gt; 三次握手 -&gt;建立TCP连接后发起http请求 -&gt;服务器收到请求并响应HTTP请求 -&gt;浏览器解析htm代码,并请求htm代码中的资源(如js、css图片等) -&gt; 断开TCP连接<br>(四次挥手)-&gt;浏览器对页面进行渲染呈现给用户<br><br><a href="https://blog.csdn.net/qq_21993785/article/details/81188253" target="_blank" rel="noopener">https://blog.csdn.net/qq_21993785/article/details/81188253</a></p><p>三、微前端<br><br>1、样式隔离<br><br><a href="https://www.yuque.com/techiu/vkrpan/urz482" target="_blank" rel="noopener">https://www.yuque.com/techiu/vkrpan/urz482</a><br>2、路由同步<br><br>3、JS沙箱<br><br>4、低代码<br></p><p>四、Flutter相关<br><br>1、<a href="https://www.jianshu.com/p/93821c12a825" target="_blank" rel="noopener">https://www.jianshu.com/p/93821c12a825</a><br><br>2、<a href="https://zhuanlan.zhihu.com/p/102193331" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102193331</a><br><br>3、<a href="https://www.jianshu.com/p/1e00b5aaf422" target="_blank" rel="noopener">https://www.jianshu.com/p/1e00b5aaf422</a><br><br>4、<a href="https://blog.csdn.net/u013095264/article/details/88802822" target="_blank" rel="noopener">https://blog.csdn.net/u013095264/article/details/88802822</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次记一些面试题总结，给自己用。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web开发中碰到的一些问题记录</title>
    <link href="https://github.com/DJoeyZhang/archives/430ebcc9.html"/>
    <id>https://github.com/DJoeyZhang/archives/430ebcc9.html</id>
    <published>2021-05-31T09:12:21.000Z</published>
    <updated>2021-07-26T02:01:57.579Z</updated>
    
    <content type="html"><![CDATA[<p>1、关闭Mac Chrome 跨域追踪：</p><p>open -n /Applications/Google\ Chrome.app/ –args –disable-web-security –user-data-dir=/Users/xxx/Documents/chromeDevData</p><p>2、第三方免密认证登录过程中使用跨域set-Cookie方式在IOS上引发的问题：<br><a href="https://www.dazhuanlan.com/2019/10/26/5db45ddb1e269/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/10/26/5db45ddb1e269/</a></p><p>3、修改数据库默认密码，查看mysql运行端口：<br>UPDATE user SET password=password(“xxx”) WHERE user=’xxx’;<br>ps -ef | grep -i mysql</p><p>4、一些CSS常用：<br><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651578836&amp;idx=3&amp;sn=ca591c6c4d0d28a5e61a76ba635abe91&amp;chksm=80253615b752bf031a7384ea2bf57ace6bb0d4069d51dcc96636540ff10df5e4c323764025d0&amp;mpshare=1&amp;scene=1&amp;srcid=0725gVlIhi20eCf77NAXBXxt&amp;sharer_sharetime=1627185735184&amp;sharer_shareid=be21b1929d4663aea6a803efa48d5e90#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651578836&amp;idx=3&amp;sn=ca591c6c4d0d28a5e61a76ba635abe91&amp;chksm=80253615b752bf031a7384ea2bf57ace6bb0d4069d51dcc96636540ff10df5e4c323764025d0&amp;mpshare=1&amp;scene=1&amp;srcid=0725gVlIhi20eCf77NAXBXxt&amp;sharer_sharetime=1627185735184&amp;sharer_shareid=be21b1929d4663aea6a803efa48d5e90#rd</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、关闭Mac Chrome 跨域追踪：&lt;/p&gt;
&lt;p&gt;open -n /Applications/Google\ Chrome.app/ –args –disable-web-security –user-data-dir=/Users/xxx/Documents/chr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter相关博文</title>
    <link href="https://github.com/DJoeyZhang/archives/3102f069.html"/>
    <id>https://github.com/DJoeyZhang/archives/3102f069.html</id>
    <published>2021-04-26T06:57:54.000Z</published>
    <updated>2021-04-26T06:58:00.733Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用flutter重构来话应用。期间参考的一些不错的资料，记录下来。<br><a id="more"></a><br>1、flutter轮子大全：<br><a href="https://pub.dev/flutter/packages" target="_blank" rel="noopener">https://pub.dev/flutter/packages</a></p><p>2、关于flutter的布局讲解：<br><a href="https://www.cnblogs.com/lxlx1798/p/11084904.html" target="_blank" rel="noopener">https://www.cnblogs.com/lxlx1798/p/11084904.html</a></p><p>3、Flutter多渠道打包：<br><a href="https://juejin.cn/post/6949901619689586719" target="_blank" rel="noopener">https://juejin.cn/post/6949901619689586719</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用flutter重构来话应用。期间参考的一些不错的资料，记录下来。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>centos折腾confluence攻略</title>
    <link href="https://github.com/DJoeyZhang/archives/a144d083.html"/>
    <id>https://github.com/DJoeyZhang/archives/a144d083.html</id>
    <published>2021-04-26T06:55:51.000Z</published>
    <updated>2021-04-26T06:55:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>团队还在刀耕火种，各种word文档满天飞，实在不能忍，于是在测试服务器上折腾了一个confluence方便团队协作。<br><a id="more"></a></p><h5 id="先提炼几个经常用的命令"><a href="#先提炼几个经常用的命令" class="headerlink" title="先提炼几个经常用的命令"></a>先提炼几个经常用的命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动wiki&lt;br&gt;</span><br><span class="line">/etc/init.d/confluence start</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">停止wiki服务&lt;br&gt;</span><br><span class="line">/etc/init.d/confluence stop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重启服务&lt;br&gt;</span><br><span class="line">/etc/init.d/confluence restart</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">卸载&lt;br&gt;</span><br><span class="line">/etc/init.d/confluence stop</span><br><span class="line">/opt/atlassian/confluence/uninstall</span><br><span class="line">rm -rf /opt/atlassian</span><br><span class="line">rm -rf /var/atlassian</span><br><span class="line">drop database wiki //登录数据库&lt;br&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据库设置</span><br><span class="line">jdbc:mysql://localhost:3306/wiki_new?useUnicode=true&amp;amp;characterEncoding=UTF8&amp;amp;sessionVariables=tx_isolation=&apos;READ-COMMITTED&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all on wiki_new.* to wiki_user@&quot;%&quot; identified by &quot;wiki_password&quot;;</span><br></pre></td></tr></table></figure><h5 id="关于confluence存储原理，方便迁移"><a href="#关于confluence存储原理，方便迁移" class="headerlink" title="关于confluence存储原理，方便迁移"></a>关于confluence存储原理，方便迁移</h5><p><a href="https://zhuanlan.zhihu.com/p/38625186" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38625186</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --delete /var/atlassian/ /confluence/atlassian/</span><br></pre></td></tr></table></figure></p><h5 id="发现一个更好的部署方案"><a href="#发现一个更好的部署方案" class="headerlink" title="发现一个更好的部署方案"></a>发现一个更好的部署方案</h5><p>1、<a href="https://www.dqzboy.com/atlassian%e5%85%a8%e5%ae%b6%e6%a1%b6%e4%bb%a5%e5%8f%8a%e6%8f%92%e4%bb%b6%e7%a0%b4%e8%a7%a3%e8%af%a6%e7%bb%86%e6%95%99%e7%a8%8b" target="_blank" rel="noopener">https://www.dqzboy.com/atlassian%e5%85%a8%e5%ae%b6%e6%a1%b6%e4%bb%a5%e5%8f%8a%e6%8f%92%e4%bb%b6%e7%a0%b4%e8%a7%a3%e8%af%a6%e7%bb%86%e6%95%99%e7%a8%8b</a></p><p>2、开源破解：<a href="https://zhile.io/2018/12/20/atlassian-license-crack.html" target="_blank" rel="noopener">https://zhile.io/2018/12/20/atlassian-license-crack.html</a></p><h5 id="好了，征文开始"><a href="#好了，征文开始" class="headerlink" title="好了，征文开始"></a>好了，征文开始</h5><p>系统：本机MacOS远程向CentOS6.6服务器安装wiki</p><p>wiki版本：5.4.4</p><p>文件：<a href="http://www.fengyachao.com/file/confluence.zip" target="_blank" rel="noopener">www.fengyachao.com/file/confluence.zip</a></p><p>开始</p><p>0.下载文件并解压，将下载的压缩文件上传到CentOS，解压缩</p><p>1.登录CentOS，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x atlassian-confluence-5.4.4-x64_1.bin</span><br><span class="line">./atlassian-confluence-5.4.4-x64_1.bin</span><br></pre></td></tr></table></figure><p>执行bin文件后，会经历三个确认</p><p>第一个，是否确认安装。[o]</p><p>第二个，选择安装方式，默认、自定义、升级现有的。[1]</p><p>第三个，确认安装。[i]</p><p>注：此时，安装已完成，不应该出现任何错误</p><p>2.http访问</p><p>观察第一步安装信息，可知，confluence打开8090端口。</p><p>访问 <a href="http://your.centos.ip:8090" target="_blank" rel="noopener">http://your.centos.ip:8090</a> 记录此页面中的Server ID</p><p>3.停止wiki服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/confluence stop</span><br></pre></td></tr></table></figure></p><p>4.将atlassian-extras-2.4.jar拷贝到本机，准备进行破解注：我这里是mac，所以如果你是windows或linux，用你的办法将文件拷贝到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp user_name@your.centos.ip:/opt/atlassian/confluence/confluence/WEB-INF/lib/atlassian-extras-2.4.jar .</span><br></pre></td></tr></table></figure><p>5.解压下载的压缩包后，里面有confluence5.1-crack.zip，将其解压得到confluence5.1-crack文件夹</p><p>将从centos下载下来的atlassian-extras-2.4.jar覆盖confluence5.1-crack里的atlassian-extras-2.4.jar</p><p>进入confluence5.1-crack/iNVISIBLE</p><p>MAC对应keygen_MacOSX.sh(linux对应keygen.sh)</p><p>由于我chmod +x keygen_MacOSX.sh后执行./keygen_MacOSX.sh报错，所以我打开keygen_MacOSX.sh看到其核心代码即是执行confluence_keygen.jar。于是，我直接执行下面命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/System/Library/Frameworks/JavaVM.framework/Versions/1.6/Home/bin/java -jar confluence_keygen.jar</span><br></pre></td></tr></table></figure></p><p>此时，会弹出UI界面</p><p>填写相关信息(name别太短)，最重要的是serverId，填写第二步获取的ServerId。</p><p>点击”patch!”，选择第四步从centos下载下来的放在confluence5.1-crack里的atlassian-extras-2.4.jar</p><p>点击”.gen!”， key文本框里会生成相应信息</p><p>6.此时confluence5.1-crack里会有atlassian-extras-2.4.jar和atlassian-extras-2.4.bak</p><p>将atlassian-extras-2.4.jar拷贝到服务器的/opt/atlassian/confluence/confluence/WEB-INF/lib/位置，覆盖此处的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp atlassian-extras-2.4.jar user_name@your.centos.ip:/opt/atlassian/confluence/confluence/WEB-INF/lib/</span><br></pre></td></tr></table></figure></p><p>7.启动wiki</p><p>/etc/init.d/confluence start<br>8.将第五步生成的key，拷贝放在第二步页面的License Key位置</p><p>9.点击“production installation”</p><p>10.在centos服务器上,将mysql驱动包放到confluence里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mysql-connector-java-5.1.24/mysql-connector-java-5.1.24-bin.jar /opt/atlassian/confluence/confluence/WEB-INF/lib/</span><br></pre></td></tr></table></figure></p><p>11.重启服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/confluence restart</span><br></pre></td></tr></table></figure></p><p>12.在页面上，选择数据库“MySQL”，点击“ Externam Database”</p><p>13.登录mysql 创建数据库及账号</p><p>我是在centos上有安装好的mysql</p><p>注：5.4.4版本的confluence，貌似对mysql的存储引擎有要求，需要是InnoDB(我第一次没有改，用的MyISAM，下一步就出错了)。</p><p> show variables like ‘%storage_engine%’;//查看默认存储引擎<br>如果是MyISAM的话，在/etc/my.cnf文件[mysqld]下添加default-storage-engine=InnoDB，重启mysql<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/mysqld restart</span><br><span class="line">mysql -uroot -p</span><br><span class="line">create database wiki character set UTF8;</span><br><span class="line">grant all on wiki.* to wiki_user@&quot;%&quot; identified by &quot;wiki_password&quot;;</span><br></pre></td></tr></table></figure></p><p>14.在页面上点击“Direct JDBC”</p><p>15.填写db信息</p><p>Driver Class Name不用变</p><p>Database URL，修正对应ip、port、database，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://localhost:3306/wiki?useUnicode=true&amp;characterEncoding=UTF8&amp;sessionVariables=storage_engine%3DInnoDB</span><br></pre></td></tr></table></figure></p><p>上面的连接符是”&amp;”不是”&amp;”，这样是没有问题的，如果你要用”&amp;”也可以尝试，但后面可能出错</p><p>User Name和Password填写第13步创建的用户名密码即可</p><p>16.点击“Next”，此时可能会有一个比较长的等待，如果此处出错了，停掉wiki服务，卸载wiki，删掉wiki文件，卸载数据库，从第一步重新来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/confluence stop</span><br><span class="line">/opt/atlassian/confluence/uninstall</span><br><span class="line">rm -rf /opt/atlassian</span><br><span class="line">rm -rf /var/atlassian</span><br><span class="line">drop database wiki //登录数据库</span><br></pre></td></tr></table></figure></p><p>此处可能出错的原因：</p><p>第2步使用域名，没用ip:port</p><p>第13步没设置默认存储引擎为InnoDB</p><p>第15步，ip、port、db或连接符不正确</p><p>当出现错误后，不要试图点击后退，修改信息，再尝试点击“Next”。直接按本步所说的做相关卸载操作，并修正产生问题的地方，从第一步开始。</p><p>17.如果上一步成功的话，点击“Empty Site”。你也可以点击“Example Site”。</p><p>18.点击“Manage users and groups within Confluence”，设置管理员相关信息。这里是“下一步”还是“确定”忘了，点击即可</p><p>19.点击further configuration</p><p>20.登录wiki，点击右上角齿轮图标下拉菜单最后一个菜单（插件），点击“upload add-on”，选择解压文件夹里的“Confluence-Language-STD-CN.jar”</p><p>21.很重要</p><p>vim /var/atlassian/application-data/confluence/confluence.cfg.xml<br>编辑此配置文件中“hibernate.connection.url”，注意连接符“&amp;”此处可能变为了“&amp;amp;”，要修改为“&amp;”修改完后重启wiki<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/confluence restart</span><br></pre></td></tr></table></figure></p><p>如果不进行此步骤，创建一些中文的内容，重启wiki，会让所有中文乱码，数据库里的数据都是乱码。</p><p>21.设置base url，job，创建空间，空间权限，用户等</p><p>22.添加一些中文内容后，重启wiki，再访问页面，看是否乱码，如果不乱码基本就没问题了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;团队还在刀耕火种，各种word文档满天飞，实在不能忍，于是在测试服务器上折腾了一个confluence方便团队协作。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>.gitignore文件设置忽略不生效的问题</title>
    <link href="https://github.com/DJoeyZhang/archives/88b92f76.html"/>
    <id>https://github.com/DJoeyZhang/archives/88b92f76.html</id>
    <published>2020-11-12T00:58:59.000Z</published>
    <updated>2020-11-12T01:01:19.497Z</updated>
    
    <content type="html"><![CDATA[<p>Git忽略规则(.gitignore配置）不生效原因和解决<br><a id="more"></a></p><p>第一种方法:</p><p>.gitignore中已经标明忽略的文件目录下的文件，git push的时候还会出现在push的目录中，或者用git status查看状态，想要忽略的文件还是显示被追踪状态。<br><br>原因是因为在git忽略目录中，新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，<br><br>这时候我们就应该先把本地缓存删除，然后再进行git的提交，这样就不会出现忽略的文件了。</p><p>解决方法: git清除本地缓存（改变成未track状态），然后再提交:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kevin ~]# git rm -r --cached .</span><br><span class="line">[root@kevin ~]# git add .</span><br><span class="line">[root@kevin ~]# git commit -m &apos;update .gitignore&apos;</span><br><span class="line">[root@kevin ~]# git push -u origin master</span><br></pre></td></tr></table></figure></p><p>需要特别注意的是：<br><br>1）.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。<br><br>2）想要.gitignore起作用，必须要在这些文件不在暂存区中才可以，.gitignore文件只是忽略没有被staged(cached)文件，对于已经被staged文件，加入ignore文件时一定要先从staged移除，才可以忽略。</p><p>第二种方法:（推荐）<br><br>在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kevin ~]# git update-index --assume-unchanged PATH                  //在PATH处输入要忽略的文件</span><br></pre></td></tr></table></figure></p><p>在使用.gitignore文件后如何删除远程仓库中以前上传的此类文件而保留本地文件<br><br>在使用git和github的时候，之前没有写.gitignore文件，就上传了一些没有必要的文件，在添加了.gitignore文件后，就想删除远程仓库中的文件却想保存本地的文件。这时候不可以直接使用”git rm directory”，这样会删除本地仓库的文件。可以使用”git rm -r –cached directory”来删除缓冲，然后进行”commit”和”push”，这样会发现远程仓库中的不必要文件就被删除了，以后可以直接使用”git add -A”来添加修改的内容，上传的文件就会受到.gitignore文件的内容约束。</p><p>额外说明：git库所在的文件夹中的文件大致有4种状态</p><p>Untracked:</p><p>未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</p><p>Unmodify:<br><br>文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改,<br><br>而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</p><p>Modified:<br><br>文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态,<br><br>使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改</p><p>Staged:<br><br>暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态.<br><br>执行git reset HEAD filename取消暂存, 文件状态为Modified</p><p>Git 状态 untracked 和 not staged的区别<br><br>1）untrack     表示是新文件，没有被add过，是为跟踪的意思。<br><br>2）not staged  表示add过的文件，即跟踪文件，再次修改没有add，就是没有暂存的意思</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git忽略规则(.gitignore配置）不生效原因和解决&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter 调试IOS真机遇到的问题</title>
    <link href="https://github.com/DJoeyZhang/archives/655c1a94.html"/>
    <id>https://github.com/DJoeyZhang/archives/655c1a94.html</id>
    <published>2020-11-10T01:47:05.000Z</published>
    <updated>2020-11-12T00:56:42.949Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些真机调试flutter遇到的坑。<br><a id="more"></a><br>1、遇到一个签名错误，开始以为是非开发者账号的问题，但是新建了一个原生demo还是报错，各种Google，说什么key chain,build settings,没有一个能解决。</p><hr><p>CodeSign /Volumes/HDD/OpenFrameworks/of_v0.9.8_osx_release/apps/plus-pool-light/pplight-ofx-098/bin/pplight-ofx-098Debug.app (in target ‘pplight-ofx-098’ from project ‘pplight-ofx-098’)<br>cd /Volumes/HDD/OpenFrameworks/of_v0.9.8_osx_release/apps/plus-pool-light/pplight-ofx-098<br>export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate</p><p>Signing Identity:     “-“</p><p> /usr/bin/codesign –force –sign - –entitlements /Volumes/HDD/OpenFrameworks/of_v0.9.8_osx_release/apps/plus-pool-light/pplight-ofx-098/build/pplight-ofx-098.build/Debug/pplight-ofx-098.build/pplight-ofx-098Debug.app.xcent –timestamp=none /Volumes/HDD/OpenFrameworks/of_v0.9.8_osx_release/apps/plus-pool-light/pplight-ofx-098/bin/pplight-ofx-098Debug.app</p><p>/Volumes/HDD/OpenFrameworks/of_v0.9.8_osx_release/apps/plus-pool-light/pplight-ofx-098/bin/pplight-ofx-098Debug.app: code object is not signed at all<br>In subcomponent: /Volumes/HDD/OpenFrameworks/of_v0.9.8_osx_release/apps/plus-pool-light/pplight-ofx-098/bin/pplight-ofx-098Debug.app/Contents/Frameworks/GLUT.framework<br>Command CodeSign failed with a nonzero exit code</p><hr><p>苦了四天，最后找到了解决方案：<br>I fixed this by adding –deep to Other Code Signing Flags in the Build Settings &gt; Signing</p><p>系统版本：10.15.7 MacOs catalina<br>Xcode版本：Version 12.1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些真机调试flutter遇到的坑。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用Linux 速查</title>
    <link href="https://github.com/DJoeyZhang/archives/107df62c.html"/>
    <id>https://github.com/DJoeyZhang/archives/107df62c.html</id>
    <published>2020-11-09T08:41:14.000Z</published>
    <updated>2020-11-12T00:58:23.246Z</updated>
    
    <content type="html"><![CDATA[<p>命令总记不住，常用的收藏一下。<br><a id="more"></a><br>1、后台启动springboot jar包<br>nohup java -jar 自己的springboot项目.jar &gt;日志文件名.log 2&gt;&amp;1 &amp;<br>2、查看所有端口状态<br>ps aux</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;命令总记不住，常用的收藏一下。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web端录音拍照及音视频解决方案调研报告</title>
    <link href="https://github.com/DJoeyZhang/archives/6b6c3a59.html"/>
    <id>https://github.com/DJoeyZhang/archives/6b6c3a59.html</id>
    <published>2020-10-28T00:59:34.000Z</published>
    <updated>2020-11-11T02:54:17.778Z</updated>
    
    <content type="html"><![CDATA[<p>前端拍照、录音、播放功能去Flash依赖化实现调研。(详细方案内容在做脱敏处理)<br><a id="more"></a></p><h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h5><p>目前前端主流的四大浏览器内核：Trident（也称IE内核）、Chromium、Blink、Gecko。</p><p>因为主流移动端系统IOS、Android浏览器内核基于Chromium/webkit，并且移动端的跨端hybrid开发方案层出不穷，所以Chromium内核应用最广，连新版的Microsoft Edge也是基于Chromium内核设计,故Chromium内核有一统江湖的趋势。</p><h5 id="调研背景："><a href="#调研背景：" class="headerlink" title="调研背景："></a>调研背景：</h5><p>目前公司的部分前端项目的录音、播放、拍照等功能依赖Flash框架。而Chrome表示，由于Adobe公司将于2020年底停止对Flash的更新，故新版的Chrome浏览器也将停止对Flash的支持。</p><p>基于以上原因，前端工程的去Flash化应未雨绸缪。</p><p>考虑到目前移动端很多业务采用hybrid方案（H5页面适配移动端，一套脚本三端运行。例如:频繁更新的运营推广页，手机M站等）。</p><p>故，前端工程的去Flash依赖动作应兼容移动端的hybrid技术方案。</p><p>基于以上，设立本次调研方向：<br>1、基于Vue构建的SPA应用拍照录音、音视频方案。<br>2、移动端开发中的hybrid解决方案。</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><p>一、基于Vue构建的SPA应用拍照录音、音视频方案：</p><p>二、移动web hybrid跨端解决方案：</p><h5 id="尾语："><a href="#尾语：" class="headerlink" title="尾语："></a>尾语：</h5><p>近年来，随着移动web应用native -&gt; hybrid -&gt; cross-platform的架构演进，跨端技术如React Native、Flutter异军突起。大前端技术主要想解决的问题其实就是如Java那样“write once,run anywhere”，为此Google还推出了Flutter For Web技术以期三端一统。<br>其中移动端利用webview 进行h5混合开发的技术手段虽在渲染效率和用户体验上照比跨端技术差。但在运营页，活动页等频繁更新的业务板块依然占有一席之地。所以前端工程应注意在移动设备上的兼容性。<br>以上为我“关于Web端拍照、录音以及音视频解决方案”的调研报告。<br>时间仓促，如有不足，敬请斧正。</p><h5 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h5><p>1、<a href="https://plainnany.github.io/2017/06/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">https://plainnany.github.io/2017/06/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E7%AE%80%E4%BB%8B/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端拍照、录音、播放功能去Flash依赖化实现调研。(详细方案内容在做脱敏处理)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库相关记录</title>
    <link href="https://github.com/DJoeyZhang/archives/76c48a64.html"/>
    <id>https://github.com/DJoeyZhang/archives/76c48a64.html</id>
    <published>2020-10-12T07:57:11.000Z</published>
    <updated>2020-10-14T02:00:28.165Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些数据库相关<br><a id="more"></a></p><p>1、使用sequel pro操作数据库<br><br><a href="https://blog.csdn.net/zs_pnzzz/article/details/79769146" target="_blank" rel="noopener">https://blog.csdn.net/zs_pnzzz/article/details/79769146</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些数据库相关&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>apktool command</title>
    <link href="https://github.com/DJoeyZhang/archives/bb48e990.html"/>
    <id>https://github.com/DJoeyZhang/archives/bb48e990.html</id>
    <published>2020-10-10T08:52:59.000Z</published>
    <updated>2020-10-10T08:54:21.759Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些apktool使用<br><a id="more"></a></p><p>1、apktool d my.apk 无权限时：chmod a+x *.sh<br><br>2、dex2jar后用JD_GUI打开报路径错误时：sudo chmod +xr</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些apktool使用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一些前端面试题</title>
    <link href="https://github.com/DJoeyZhang/archives/706e1d98.html"/>
    <id>https://github.com/DJoeyZhang/archives/706e1d98.html</id>
    <published>2020-09-14T07:55:10.000Z</published>
    <updated>2020-10-19T07:15:04.602Z</updated>
    
    <content type="html"><![CDATA[<p>preface：<br><br>应朋友邀请，去新公司做前端负责人。公司目前前端工作内容主要是后台管理界面。一些老的项目是vue开发维护的。技术栈主要在vue-admin和react-admin。<br><br>记录整理的一些面试题，着重考察候选人前端基础和框架的熟悉程度，提升考察候选人对框架的理解和一些发散思维。<br><a id="more"></a></p><h5 id="考察范围："><a href="#考察范围：" class="headerlink" title="考察范围："></a>考察范围：<br></h5><h6 id="一、JS基础考察："><a href="#一、JS基础考察：" class="headerlink" title="一、JS基础考察："></a>一、JS基础考察：<br></h6><p>1、闭包和作用域,箭头函数中的this。<br><br>2、深浅拷贝的区别。<br><br>3、http\https\websocket区别和使用场景，常用的请求方法及状态码。<br><br>4、浏览器缓存。强缓存和协商缓存区别。<br></p><h6 id="二、Vue基础考察"><a href="#二、Vue基础考察" class="headerlink" title="二、Vue基础考察:"></a>二、Vue基础考察:<br></h6><p>1、组件生命周期？哪个钩子函数中可以拿到Dom节点, 在created还是mounted？<br><br>2、父子组件通信，事件和属性的传递模式。<br><br>3、MVC \ MVVM 的理解？Vue借鉴了哪种模式？双向绑定的数据，变量污染如何排查。<br><br>4、数据驱动父组件重绘时，部分子组件不想重绘，如何做? (keep=alive) <br></p><h6 id="三、React基础考察"><a href="#三、React基础考察" class="headerlink" title="三、React基础考察:"></a>三、React基础考察:<br></h6><p>1、组件key的作用。<br><br>2、lodash 防抖和节流。<br><br>3、组件生命周期，网络请求通常写在哪个钩子上？虚拟DOM 的diff算法处理，shouldupdate回调时机，顺便问问渲染性能优化。<br><br>5、vuex和Redux的设计和作用。<br></p><h6 id="四、针对简历项目提问考察"><a href="#四、针对简历项目提问考察" class="headerlink" title="四、针对简历项目提问考察"></a>四、针对简历项目提问考察<br></h6><h6 id="五、发散思维考察："><a href="#五、发散思维考察：" class="headerlink" title="五、发散思维考察："></a>五、发散思维考察：<br></h6><p>1、JQ和vue\react比较，JQ有哪些缺陷。<br><br>2、从浏览器地址栏输入url到页面加载渲染出来，都发生了什么。<br><br>3、Vue工程，调试run serve没有问题，但是build后的dist在跑在部分浏览器有问题，并且控制台输出信息有限（SCRIPT1002），如何排查？<br>5、大数据可视化方面：D3.js和echarts比较。<br>6、职业规划。期望薪资。<br></p><h5 id="六、评价维度："><a href="#六、评价维度：" class="headerlink" title="六、评价维度："></a>六、评价维度：<br></h5><p>1、基础知识<br><br>2、框架熟悉度<br><br>3、语言表达、协作沟通能力<br><br>4、可塑性（学习意愿）<br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;preface：&lt;br&gt;&lt;br&gt;应朋友邀请，去新公司做前端负责人。公司目前前端工作内容主要是后台管理界面。一些老的项目是vue开发维护的。技术栈主要在vue-admin和react-admin。&lt;br&gt;&lt;br&gt;记录整理的一些面试题，着重考察候选人前端基础和框架的熟悉程度，提升考察候选人对框架的理解和一些发散思维。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>来话应用Flutter重构可研</title>
    <link href="https://github.com/DJoeyZhang/archives/61fe53de.html"/>
    <id>https://github.com/DJoeyZhang/archives/61fe53de.html</id>
    <published>2020-08-31T01:00:27.000Z</published>
    <updated>2020-08-31T05:37:06.341Z</updated>
    
    <content type="html"><![CDATA[<p>目标和资源：<br><br>    来话应用一期Android端上线后，希望以flutter重构业务逻辑，实现ADR/IOS双端上线。 <br><br>   目前组内可供开发人力，Android 3人，IOS/MACOS 2人。<br><a id="more"></a></p><h5 id="一、工作拆解："><a href="#一、工作拆解：" class="headerlink" title="一、工作拆解："></a>一、工作拆解：</h5><h6 id="1、架构设计："><a href="#1、架构设计：" class="headerlink" title="1、架构设计："></a>1、架构设计：</h6><p>来话Android端架构设计：<br><br>模块化解耦合，抽取module_base,module_function,module_user,app四个模块，其中module_base承载应用的基类和MVVM框架设计，module_function和module_user承载产品的具体功能函数和用户的信息管理，app模块是整个应用的壳工程，用来对接一些三方SDK。工程采用了jetbrain anko,okhttp3/retrofit/rxjava/dagger2/glide等一系列流行框架作为脚手架。<br></p><p>来话Flutter端架构设计：<br><br>总体设计上可复用来话Android端架构。工具框架参考flutter开发者社区，大体覆盖了我方功能需求。但flutter所选框架在Adr/IOs双端的兼容性需要双端工程师进行调试。</p><h6 id="2、Tencent-IM-SDK-SensorSDK-TingYun-SDK-XGPush的桥接（工作量大，重难点）"><a href="#2、Tencent-IM-SDK-SensorSDK-TingYun-SDK-XGPush的桥接（工作量大，重难点）" class="headerlink" title="2、Tencent IM SDK / SensorSDK / TingYun SDK / XGPush的桥接（工作量大，重难点）"></a>2、Tencent IM SDK / SensorSDK / TingYun SDK / XGPush的桥接（工作量大，重难点）</h6><p>以上四者SDK，分别提供了来话的 即时通话能力 、 商化统计能力 、 性能监控能力 、推送及接收消息能力。且此四者SDK并无Flutter版本，需要双端工程师根据SDK的开放API，选定合适版本进行桥接编写。</p><h6 id="3、工具类封装、基类编写："><a href="#3、工具类封装、基类编写：" class="headerlink" title="3、工具类封装、基类编写："></a>3、工具类封装、基类编写：</h6><p>此工作采用Dart,由Adr工程师编写，IOS端工程师负责单侧调试。</p><h6 id="4、功能页面的编写：（工作量大-且琐碎）"><a href="#4、功能页面的编写：（工作量大-且琐碎）" class="headerlink" title="4、功能页面的编写：（工作量大,且琐碎）"></a>4、功能页面的编写：（工作量大,且琐碎）</h6><p>此工作采用Dart,由Adr工程师编写，IOS端工程师负责单侧调试。</p><h6 id="5、权限功能编写："><a href="#5、权限功能编写：" class="headerlink" title="5、权限功能编写："></a>5、权限功能编写：</h6><p>来话产品所需求（eg:静默下载，本地通讯录联系人等）的一系列敏感权限，IOS工程师需评估其对于上架审核有无影响。部分诸如强制更新，后台唤起等功能IOS端恐怕实现困难，需寻找替代方案。</p><h5 id="二、风险评估："><a href="#二、风险评估：" class="headerlink" title="二、风险评估："></a>二、风险评估：</h5><h6 id="1、-开发人员技术栈现状："><a href="#1、-开发人员技术栈现状：" class="headerlink" title="1、 开发人员技术栈现状："></a>1、 开发人员技术栈现状：</h6><p>有flutter开发经验的Android工程师仅1人。其余四人需要培训学习后兼顾进行开发，人力投入上难以 all in。</p><h6 id="2、-应用权限申请："><a href="#2、-应用权限申请：" class="headerlink" title="2、 应用权限申请："></a>2、 应用权限申请：</h6><p>来话Android端申请了许多诸如：通讯录读取、静默下载、浮动在上层应用等敏感权限。IOS端恐怕无法申请并过审。</p><h5 id="三、开发、协作模式："><a href="#三、开发、协作模式：" class="headerlink" title="三、开发、协作模式："></a>三、开发、协作模式：</h5><p>人力现状：<br>Android工程师充足，但手中有其他工作；IOS工程师人力少，手中有其他工作且处于异地。</p><h6 id="建议的协作开发模式："><a href="#建议的协作开发模式：" class="headerlink" title="建议的协作开发模式："></a>建议的协作开发模式：</h6><p>1、Android端先行进入调研开发。工作优先级：SDK的桥接封装协议制定及编码 &gt; 框架设计、基类、工具编写 &gt; 具体功能界面编写实现。</p><p>2、IOS端待SDK封装协议制定后进入开发。根据Android端开发进度进行适配(android端需制定短期里程碑计划，定期输出flutter编码供IOS端适配调试)。</p><h5 id="四、工期评估："><a href="#四、工期评估：" class="headerlink" title="四、工期评估："></a>四、工期评估：</h5><h6 id="1、SDK封装协议及编码开发：-—-共计：30人日"><a href="#1、SDK封装协议及编码开发：-—-共计：30人日" class="headerlink" title="1、SDK封装协议及编码开发： —-共计：30人日"></a>1、SDK封装协议及编码开发： —-共计：30人日</h6><pre><code>Tencent IM SDK 桥接协议制定编写。----7人日SensorSDK 桥接协议制定编写。----7人日TingYun SDK 桥接协议制定编写。----7人日XGPush SDK 桥接协议制定编写。----7人日调试自测。 ----2人日</code></pre><h6 id="2、架构设计、框架开发：-—-共计：6人日"><a href="#2、架构设计、框架开发：-—-共计：6人日" class="headerlink" title="2、架构设计、框架开发： —-共计：6人日"></a>2、架构设计、框架开发： —-共计：6人日</h6><pre><code>工程架构搭建。----2人日依赖管理。----2人日调试自测。 ----2人日</code></pre><h6 id="3、功能页面编写：-—-共计：45人日"><a href="#3、功能页面编写：-—-共计：45人日" class="headerlink" title="3、功能页面编写： —- 共计：45人日"></a>3、功能页面编写： —- 共计：45人日</h6><pre><code>首页通话记录模块。----2人日首页通讯录模块。 ----2人日首页设置模块。----1人日消息模块。----2人日预约功能模块。 ---- 3人日多选联系人功能模块。 ----3人日设置模块、关于模块、扫一扫添加联系人模块。----3人日添加联系人、通讯录校验、好友邀请模块。----4人日下载升级功能。 ----3人日单人、多人通话功能。 ----14人日登陆注册模块。----2人日所有模块埋点统计。----2人日调试自测。 ----4人日</code></pre><h6 id="4、基类、工具类编写：-—-共计：5人日"><a href="#4、基类、工具类编写：-—-共计：5人日" class="headerlink" title="4、基类、工具类编写： —-共计：5人日"></a>4、基类、工具类编写： —-共计：5人日</h6><h6 id="5、权限体系编写：-—-6人日"><a href="#5、权限体系编写：-—-6人日" class="headerlink" title="5、权限体系编写： —-6人日"></a>5、权限体系编写： —-6人日</h6><p>共计：92人日。（预估前提：在重构工作无产品干预的前提下，仅以我个人开发能力all in状态进行Android端flutter重构的乐观评估。IOS侧适配工期需IOS工程师另行评估）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目标和资源：&lt;br&gt;&lt;br&gt;    来话应用一期Android端上线后，希望以flutter重构业务逻辑，实现ADR/IOS双端上线。 &lt;br&gt;&lt;br&gt;   目前组内可供开发人力，Android 3人，IOS/MACOS 2人。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记录一些好用的配置工具和lint配置</title>
    <link href="https://github.com/DJoeyZhang/archives/70f14e75.html"/>
    <id>https://github.com/DJoeyZhang/archives/70f14e75.html</id>
    <published>2020-08-28T00:56:54.000Z</published>
    <updated>2020-08-28T00:58:15.200Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器。<br><a id="more"></a></p><p>1、 cc 开发eslint 配置<br><br><a href="https://www.dazhuanlan.com/2020/01/06/5e12ae47f1581/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2020/01/06/5e12ae47f1581/</a></p><p>2、MacBook brew update 慢的问题。<br><a href="https://www.jianshu.com/p/edfe9af41117" target="_blank" rel="noopener">https://www.jianshu.com/p/edfe9af41117</a></p><p>3、在mac终端先cd对应目录，然后执行以下命令，目录下会多了一些jpg格式的图片。<br>for i in .CR2; do sips -s format jpeg $i –out “${i%.}.jpg”; done</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工欲善其事，必先利其器。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一起来找茬开发手记。cocos creator探索之路</title>
    <link href="https://github.com/DJoeyZhang/archives/8434bd43.html"/>
    <id>https://github.com/DJoeyZhang/archives/8434bd43.html</id>
    <published>2020-08-20T16:10:53.000Z</published>
    <updated>2020-08-25T02:19:58.835Z</updated>
    
    <content type="html"><![CDATA[<p>要睡了,先随便记点，有空再整理。<br><a id="more"></a></p><p>0、关于上次讨论热区配置问题：解决方案如上图<br>    设图片width，height均为1.<br>    左上角建立坐标系，x1,x2,y1,y2分别为x轴坐标/width，y轴坐标/height的比例值。<br>    x1,x2,y1,y2 in (0,1)</p><pre><code>给出配置文件数据结构形如：{url:&quot;www.picture.com&quot;,hotArea:[    {x1:0.5,x2:0.75,y1:0.25,y2:0.5},    ...]如此运营每次设置好热区后，只需要计算一下这四个数就可以了，比切九宫格简单。配置像素值不可取，因图片在前端展示可能会压缩，且按照dip、pt或者rem适配，在不同设备上，px值应该不一样。</code></pre><p>}</p><p>1、关于前端技术选型：</p><pre><code>抖音小游戏支持的主流2种引擎：Cocos Creator,Egret白鹭其中egret引擎文档已经上次更新已经是16年。抛弃。经技术社区调研，CC具备以下优点：version 2.4.2 support了字节小游戏以及字节小游戏开放域的构建发布。引擎侵入性很小，可在字节开发者工具中进行产物二次开发。ES6/7语法，JS栈亲和。API覆盖全面，文档详细。综上，前端决定选用CC引擎。</code></pre><p>2、关于游戏服务端调研：</p><pre><code>浏览多个技术社区和逼乎专栏，多数推荐网易LeanCloud作为游戏服务的后端支持。LeanCloud提供了详细的多人在线游戏server解决方案。部署和运维看起来也挺方便的。收费看着也还行，官网丢出来供服务端大佬参考：https://leancloud.cn/docs/multiplayer-server.html#hash1086233181</code></pre><p>3、Cocos Creator .gitIgnore config<br><a href="https://blog.csdn.net/themagickeyjianan/article/details/82901189" target="_blank" rel="noopener">https://blog.csdn.net/themagickeyjianan/article/details/82901189</a></p><p>4、坑。8月23日进开发，因产品设计较多的路由页面，突发奇想用小程序模版开发。结果25日发现小程序中调用不到小游戏的API，并且发布也归类不到小游戏，唉，重头再来吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要睡了,先随便记点，有空再整理。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin开发编码规范</title>
    <link href="https://github.com/DJoeyZhang/archives/10213c17.html"/>
    <id>https://github.com/DJoeyZhang/archives/10213c17.html</id>
    <published>2020-07-28T02:00:04.000Z</published>
    <updated>2020-07-28T03:41:49.657Z</updated>
    
    <content type="html"><![CDATA[<p></p><h4>Preface:</h4><br>众所周知，Android团队已经接纳Kotlin为其平台性开发语言，可以预见将来会有越来越多的Android项目用Kotlin写成。随着Kotlin被引入到不同的开发团队，与其相关的代码规范也会越来越受关注。<br><a id="more"></a><br>以下是我查找多方资料初步整理的kotlin编码规范，如有不妥，敬请斧正。<p></p><p></p><h5>命名格式</h5><br>总体来说，Kotlin命名格式要和Java命名规范保持一致，因为Kotlin也是JVM兼容的语言。<p></p><p></p><h5>包名</h5><br>包的命名规则和Java一样：全小写，当遇到多个词连接的场景，不要使用下划线(_)和连字号(-)。<p></p><p><b>推荐</b><br><br>package vn.asiantech.android<br><br><b>不推荐</b><br><br>package Vn.Asiantech.Android</p><p></p><h5>类和接口</h5><br>命名遵守大驼峰规则（首字母大写）。<p></p><p><b>推荐</b><br><br>HomeActivity<br><br>MainFragment<br></p><p></p><h5>方法</h5><br>命名遵守小驼峰规则（首字母小写）。<p></p><p><b>推荐</b><br><br>setData<br><br>getApiNews</p><p></p><h5>字段（Fields）</h5><br>总体来说，字段命名遵守小驼峰规则，不建议使用匈牙利法。<p></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  var publicField: Int = 0</span><br><span class="line">  val person = Person()</span><br><span class="line">  private var privateField: Int?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而伴生对象中的常量定义要遵守规则：全大写，单词连接使用下划线。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">companion object &#123;</span><br><span class="line">  const val THE_ANSWER = 42</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="变量和参数"><a href="#变量和参数" class="headerlink" title="变量和参数"></a>变量和参数</h5><p>一句话概括： 小驼峰命名法。<br><br>不建议使用单个字符的变量，除非是循环中的临时变量。</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>首字母缩略词作为完整单词看待，适时选择命名规则。</p><p><b>推荐</b><br><br>XMLHTTPRequest<br><br>URL: String? <br><br>findPostByID<br><br><b>不推荐</b><br><br>XmlHttpRequest<br><br>url: String<br><br>findPostById<br></p><h5 id="间距"><a href="#间距" class="headerlink" title="间距"></a>间距</h5><p><b>缩进</b><br><br>缩进使用4个空格，不建议使用tabs - 制表符。</p><p><b>闭包</b><br><br>闭包的缩进使用2个空格，</p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i in 0..9) &#123;</span><br><span class="line">  Log.i(TAG, &quot;index=&quot; + i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i in 0..9) &#123;</span><br><span class="line">    Log.i(TAG, &quot;index=&quot; + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h5><p>新的换行缩进使用4个空格，而不是默认的8个。</p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val widget: CoolUiWidget =</span><br><span class="line">    someIncrediblyLongExpression(that, reallyWouldNotFit, on, aSingle, line)</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val widget: CoolUiWidget =</span><br><span class="line">        someIncrediblyLongExpression(that, reallyWouldNotFit, on, aSingle, line)</span><br></pre></td></tr></table></figure></p><h5 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h5><p>每行不应超过130个字符，这在Android Studio内可以配置。<br><br>如果单行代码超过限制需要换行显示，使用, / : / { , = 作为首行的结尾。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun setData(name: String, age: Int, class: String, date: String, message: String,</span><br><span class="line">     time: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun getInfo(name: String, birth: String, age: Int, weight: Float, hight: Float) =</span><br><span class="line">   getInfo().apply &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data class Animal(private val weight: Float, private val hight: Float) :</span><br><span class="line">         AbstractAnimal() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="垂直间距"><a href="#垂直间距" class="headerlink" title="垂直间距"></a>垂直间距</h5><p>方法体之间保留一个空行，这样可以让结构清晰。<br><br>方法体内的空行用来分割不同功能，这样如果一个方法内分多个部分，也许需要重构代码了。<br></p><h5 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h5><p>类型和父类型之间的冒号前面要保留空格，而变量和类型之间的冒号前没有空格。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Foo&lt;out T : Any&gt; : Bar &#123;</span><br><span class="line">    fun foo(a: Int): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 申明变量类型</span><br><span class="line"></span><br><span class="line">val firstName: String</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Foo&lt;out T:Any&gt;: Bar &#123;</span><br><span class="line">    fun foo(a : Int):T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 申明变量类型</span><br><span class="line"></span><br><span class="line">val firstName:String</span><br></pre></td></tr></table></figure></p><h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><p>在定义类的时候，在结构体的右括号和类主题的左括号之间保留空格，结构体的每个参数单行显示。<br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User(</span><br><span class="line">    public open var firstName: String,</span><br><span class="line">    public open var lastName: String</span><br><span class="line">) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class User(public open var firstName: String, public open var lastName: String)&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>在定义子类或实现接口的时候，上面提到的规则仍然适用，且冒号和父类名之间要保留空格，冒号和结构体之间不需要空格。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User(</span><br><span class="line">    public open var firstName: String,</span><br><span class="line">    public open var lastName: String</span><br><span class="line">): RealmObject() &#123;&#125;</span><br></pre></td></tr></table></figure></p><h5 id="分号（-）"><a href="#分号（-）" class="headerlink" title="分号（;）"></a>分号（;）</h5><p>在Kotlin中避免使用分号。</p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val horseGiftedByTrojans = true</span><br><span class="line">if (horseGiftedByTrojans) &#123;</span><br><span class="line">  bringHorseIntoWalledCity()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val horseGiftedByTrojans = true;</span><br><span class="line">if (horseGiftedByTrojans) &#123;</span><br><span class="line">  bringHorseIntoWalledCity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="括号格式"><a href="#括号格式" class="headerlink" title="括号格式"></a>括号格式</h5><p>方法体的大括号和其他大括号首括号和前面代码在同一行，尾括号新起一行。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  fun doSomething() &#123;</span><br><span class="line">    if (someTest) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">&#123;</span><br><span class="line">  fun doSomething()</span><br><span class="line">  &#123;</span><br><span class="line">    if (someTest)</span><br><span class="line">    &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="括号格式-1"><a href="#括号格式-1" class="headerlink" title="括号格式"></a>括号格式</h5><p>条件判断语句必须内嵌在括号里，无论其是多少行。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (someTest) &#123;</span><br><span class="line">  doSomething()</span><br><span class="line">&#125;</span><br><span class="line">if (someTest) &#123; doSomethingElse() &#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (someTest)</span><br><span class="line">  doSomething()</span><br><span class="line">if (someTest) doSomethingElse()</span><br></pre></td></tr></table></figure></p><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>尽可能使用Kotlin原生类型。</p><h5 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h5><p>避免显式地声明Unit类型，因为不显式声明返回类型的函数都会返回 Unit 类型。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun doSomething()</span><br></pre></td></tr></table></figure></p><p>不推荐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun doSomething(): Unit</span><br></pre></td></tr></table></figure></p><h5 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h5><p>优先使用类型推导。（对编译速度有少许影响？）<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val something = MyType()</span><br><span class="line">val meaningOfLife = 42</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val something: MyType = MyType()</span><br><span class="line">val meaningOfLife: Int = 42</span><br></pre></td></tr></table></figure></p><h5 id="常量-vs-变量"><a href="#常量-vs-变量" class="headerlink" title="常量 vs 变量"></a>常量 vs 变量</h5><p>定义常量时使用关键词val， 定义变量时使用关键词var。<br><br>建议： 把所有的值使用val定义，且只在编译器警告的时候修订为var。</p><h5 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h5><p>伴生对象应定义在类文件的上面，而关于伴生对象的命名规范要遵守Java标准规范。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MainFragment: Fragment() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val TYPE_VIEW_HEADER = 0</span><br><span class="line">        const val TYPE_VIEW_FOOTER = 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MainFragment: Fragment() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val TypeViewHeader = 0</span><br><span class="line">        val TypeViewFooter = 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>推荐使用字符串插值语法糖。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val fullName = &quot;$&#123;user.firstName&#125; $&#123;user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val fullName = user.firstName + &quot; &quot; + user.lastName</span><br></pre></td></tr></table></figure></p><h5 id="选配型（-）"><a href="#选配型（-）" class="headerlink" title="选配型（?）"></a>选配型（?）</h5><p>变量和方法返回可以声明为选配型，这种情况赋值null也是允许的。<br></p><p>使用隐式拆包!!时候要小心，只能在确认实例对象在被使用前已经初始化，如在Activity方法onCreate使用的子视图。<br></p><p>在为选配型变量和参数命名的时候，不用使用类maybeView 和 optionalString的名称，因为选配类型已经表明了这一点。<br></p><p>在访问选配型变量值时，可使用可选链（Optional Chaining）。<br></p><p><b>eg:editText?.setText(“foo”)</b></p><h5 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h5><p>使用IDE提示<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val array = ArrayList&lt;Int&gt;()</span><br><span class="line">array[0]</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">activity().finish()</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val array = ArrayList&lt;Int&gt;()</span><br><span class="line">array.get(0)</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">getActivity().finish()</span><br></pre></td></tr></table></figure></p><p>it 在 Lambda 语句中适应较广范围。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  it?.let &#123; animal -&gt; animal.foo() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; animal -&gt; </span><br><span class="line">  animal?.let &#123; it.foo() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用类型推断，除非是难以理解的时候。"><a href="#使用类型推断，除非是难以理解的时候。" class="headerlink" title="使用类型推断，除非是难以理解的时候。"></a>使用类型推断，除非是难以理解的时候。</h5><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//属性</span><br><span class="line">val age = 0       // Int</span><br><span class="line">val foo = 10L     // Long</span><br><span class="line">val height = 100f // Float</span><br><span class="line"></span><br><span class="line">//函数</span><br><span class="line">// return Boolean</span><br><span class="line">fun Context.isConnectToWifi() =</span><br><span class="line">      (getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager)</span><br><span class="line">         .activeNetworkInfo?.type == ConnectivityManager.TYPE_WIFI</span><br><span class="line"></span><br><span class="line">// return Point</span><br><span class="line">fun Display.getSize(): Point = Point().apply &#123; getSize(this) &#125;</span><br></pre></td></tr></table></figure></p><h5 id="不要显式地写for循环。"><a href="#不要显式地写for循环。" class="headerlink" title="不要显式地写for循环。"></a>不要显式地写for循环。</h5><p>Kotlin中集合的支持forEach遍历。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(0..9).forEach &#123;</span><br><span class="line">// todo somethings</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(0..9).forEachIndexed &#123; index, value -&gt;</span><br><span class="line">// todo somethings</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i in 0..9) &#123;</span><br><span class="line">  // todo somethings</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用-to-快速创建Pair类的实例。"><a href="#使用-to-快速创建Pair类的实例。" class="headerlink" title="使用 to 快速创建Pair类的实例。"></a>使用 to 快速创建Pair类的实例。</h5><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val pair = Pair(foo, bar)</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val pair = foo to bar</span><br></pre></td></tr></table></figure></p><h5 id="使用优雅的类型转换。"><a href="#使用优雅的类型转换。" class="headerlink" title="使用优雅的类型转换。"></a>使用优雅的类型转换。</h5><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dog as? Animal ?: throw IllegalArgumentException(&quot;not Animal!&quot;)</span><br><span class="line">dog.foo()</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (dog !is Animal) &#123;</span><br><span class="line">    throw IllegalArgumentException(&quot;not Animal!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">dog.foo()</span><br></pre></td></tr></table></figure></p><h5 id="Getters-amp-Setters"><a href="#Getters-amp-Setters" class="headerlink" title="Getters &amp; Setters"></a>Getters &amp; Setters</h5><p> Kotlin中推荐直接访问属性。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// syntax</span><br><span class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 自定义setter</span><br><span class="line">var stringRepresentation: String</span><br><span class="line">    get() = this.toString()</span><br><span class="line">    set(value) &#123;</span><br><span class="line">        setDataFromString(value) // parses the string and assigns values to other properties</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="When语句"><a href="#When语句" class="headerlink" title="When语句"></a>When语句</h5><p>Kotlin的When语句和Java中的Switch有稍许区别，如不会fall through。如果不同的case具有相同的处理策略，使用逗号（,）,并且else语句是必须的。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">when (anInput) &#123;</span><br><span class="line">  1, 2 -&gt; doSomethingForCaseOneOrTwo()</span><br><span class="line">  3 -&gt; doSomethingForCaseThree()</span><br><span class="line">  else -&gt; println(&quot;No case satisfied&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">when (anInput) &#123;</span><br><span class="line">  1 -&gt; doSomethingForCaseOne()</span><br><span class="line">  2 -&gt; doSomethingForCaseOneOrTwo()</span><br><span class="line">  3 -&gt; doSomethingForCaseThree()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="变量可视性修饰符"><a href="#变量可视性修饰符" class="headerlink" title="变量可视性修饰符"></a>变量可视性修饰符</h5><p>默认修饰符是public，如果没有其他需要可以省略。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val wideOpenProperty = 1</span><br><span class="line">private val myOwnPrivateProperty = &quot;private&quot;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public val wideOpenProperty = 1</span><br><span class="line">private val myOwnPrivateProperty = &quot;private&quot;</span><br></pre></td></tr></table></figure></p><h5 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h5><p>对于每个类，方法和成员变量，访问控制修饰符要显示定义清晰。<br></p><h5 id="变量和字段"><a href="#变量和字段" class="headerlink" title="变量和字段"></a>变量和字段</h5><p>单行一个声明。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username: String</span><br><span class="line">twitterHandle: String</span><br></pre></td></tr></table></figure></p><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>普遍来说，每一个文件定义一个类，对于适合的场合依然可以使用内部类。<br></p><h5 id="Data-类型对象"><a href="#Data-类型对象" class="headerlink" title="Data 类型对象"></a>Data 类型对象</h5><p>对于简单的数据结构，推荐使用data类。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class Person(val name: String)</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name: String) &#123;</span><br><span class="line">  override fun toString() : String &#123;</span><br><span class="line">    return &quot;Person(name=$name)&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>优先使用静态变量，避免使用枚举类，因为内存开销太大。<br><br>如果枚举类没有其他方法，不用换行。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private enum CompassDirection &#123; EAST, NORTH, WEST, SOUTH &#125;</span><br></pre></td></tr></table></figure></p><h5 id="注解（Annotations）"><a href="#注解（Annotations）" class="headerlink" title="注解（Annotations）"></a>注解（Annotations）</h5><p>使用Java式标准注解，特别是override， 关键字要和函数的声明保持同一行。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">  super.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">  super.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Annotations应该在类的上面，-内联如果注解类中的字段"><a href="#Annotations应该在类的上面，-内联如果注解类中的字段" class="headerlink" title="Annotations应该在类的上面， 内联如果注解类中的字段,"></a>Annotations应该在类的上面， 内联如果注解类中的字段,</h5><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Root(strict=false) </span><br><span class="line">public open class User (</span><br><span class="line">    @field:Element public open var firstName: String? = &quot;&quot;,</span><br><span class="line">    @field:Element public open var lastName: String? = &quot;&quot;,</span><br><span class="line">) &#123;...&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Root(strict=false) public open class User (</span><br><span class="line">    @field:Element </span><br><span class="line">    public open var firstName: String? = &quot;&quot;,</span><br><span class="line">    @field:Element </span><br><span class="line">    public open var lastName: String? = &quot;&quot;,</span><br><span class="line">) &#123;...&#125;</span><br></pre></td></tr></table></figure></p><h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><p>XML文件命名<br><br>文件名要以展示视图的类型作为前缀。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">activity_login.xml</span><br><span class="line">fragment_main_screen.xml</span><br><span class="line">button_rounded_edges.xml</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">login.xml</span><br><span class="line">main_screen.xml</span><br><span class="line">rounded_edges_button.xml</span><br></pre></td></tr></table></figure></p><h5 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h5><p>和Java一样， XML文件使用2个字符缩进。<br></p><p>使用上下文相关的XML<br><br>任何时候，XML都要定义在相关的文件内。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Strings =&gt; res/values/strings.xml</span><br><span class="line">Styles =&gt; res/values/styles.xml</span><br><span class="line">Colors =&gt; res/color/colors.xml</span><br><span class="line">Animations =&gt; res/anim/</span><br><span class="line">Drawable =&gt; res/drawable</span><br></pre></td></tr></table></figure><h4 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h4><p>我配置的一个Formatter Config,个人感觉比较好用，如有优化，欢迎PR:<br><br><a href="https://github.com/DJoeyZhang/FormatterSetting.gitt">Formatter传送门</a><br><br>参考资料：<br><br><a href="https://kotlinlang.org/docs/reference/properties.html" target="_blank" rel="noopener">kotlin官方文档</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h4&gt;Preface:&lt;/h4&gt;&lt;br&gt;众所周知，Android团队已经接纳Kotlin为其平台性开发语言，可以预见将来会有越来越多的Android项目用Kotlin写成。随着Kotlin被引入到不同的开发团队，与其相关的代码规范也会越来越受关注。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Thread.sleep(0)</title>
    <link href="https://github.com/DJoeyZhang/archives/a239bad0.html"/>
    <id>https://github.com/DJoeyZhang/archives/a239bad0.html</id>
    <published>2020-06-10T01:42:03.000Z</published>
    <updated>2020-06-11T06:54:47.185Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我们可能经常会用到 Thread.Sleep 函数来吧使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？<br></p><h6 id="思考下面这两个问题："><a href="#思考下面这两个问题：" class="headerlink" title="思考下面这两个问题："></a>思考下面这两个问题：<br></h6><p>假设现在是 2020-05-24 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2020-05-24 12:00:01.000 的时候，这个线程会不会被唤醒？<br><br>某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。<br><br>既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？<br><br><a id="more"></a><br>我们先回顾一下操作系统原理<br><br>操作系统中，CPU竞争有很多种策略。<br>Unix系统使用的是时间片算法，而Windows则属于抢占式的。在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。<br><br>所谓抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢 占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。<br><br>在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一 次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他。<br><br>Sleep函数就是告诉操作系统“在未来的多少毫秒内我不参与CPU竞争”。<br><br>对于第一个问题，答案是：不一定。因为你只是告诉操作系统：在未来的1000毫秒内我不想再参与到CPU竞争。那么1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。<br><br>与此相似的，Thread有个Resume函数，是用来唤醒挂起的线程的。好像上面所说的一样，这个函数只是“告诉操作系统我从现在起开始参与CPU竞争了”，这个函数的调用并不能马上使得这个线程获得CPU控制权。<br><br>对于第二个问题，答案是：有，而且区别很明显。Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。<br><br>另外，虽然上面提到说“除非它自己放弃使用 CPU ，否则将完全霸占 CPU”，但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。至于我们的大循环造成程序假死，并不是因为这个线程一直在霸占着CPU。实际上在这段时间操作系统已经进行过多次CPU竞争了，只不过其他线程在获得CPU控制权之后很短时间内马上就退出了，于是就又轮到了这个线程继续执行循环，于是就又用了很久才被操作系统强制挂起。。。因此反应到界面上，看起来就好像这个线程一直在霸占着CPU一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;我们可能经常会用到 Thread.Sleep 函数来吧使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？&lt;br&gt;&lt;/p&gt;
&lt;h6 id=&quot;思考下面这两个问题：&quot;&gt;&lt;a href=&quot;#思考下面这两个问题：&quot; class=&quot;headerlink&quot; title=&quot;思考下面这两个问题：&quot;&gt;&lt;/a&gt;思考下面这两个问题：&lt;br&gt;&lt;/h6&gt;&lt;p&gt;假设现在是 2020-05-24 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2020-05-24 12:00:01.000 的时候，这个线程会不会被唤醒？&lt;br&gt;&lt;br&gt;某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。&lt;br&gt;&lt;br&gt;既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter常用命令行（持续更新）</title>
    <link href="https://github.com/DJoeyZhang/archives/148810a7.html"/>
    <id>https://github.com/DJoeyZhang/archives/148810a7.html</id>
    <published>2020-04-13T02:05:27.000Z</published>
    <updated>2020-04-13T10:14:08.666Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些flutter开发遇到的问题和一些常用的flutter命令行，方便调试。<br><a id="more"></a></p><p>一、<br><br>flutter    列出所有的命令<br><br>flutter help    查看具体命令的帮助信息<br><br>flutter doctor    查看是否还需要安装其它依赖<br><br>flutter doctor -v    查看详细信息<br><br>flutter channel    查看 Flutter SDK 所有分支<br><br>flutter channel stable    切换分支<br><br>flutter upgrade    升级 Flutter SDK（此命令会同时更新 Flutter SDK 和你的 Flutter 项目依赖包）<br><br>flutter packages get    获取项目所有的依赖包（只更新项目依赖包，不包括 Flutter SDK）<br><br>flutter packages upgrade    获取项目所有依赖包的最新版本（只更新项目依赖包，不包括 Flutter SDK）<br><br>flutter analyze    分析项目代码<br><br>flutter build apk    <br><br>flutter build ios    <br></p><p>二、<br><br>查看Flutter版本<br><br>查看当前版本<br><br>flutter  –version<br><br>查看所有版本<br><br>flutter version<br><br>打印所有命令行用法信息 <br><br>flutter  -h或者flutter  –help<br><br>分析项目的Dart代码。<br><br>flutter  analyze<br><br>Flutter构建命令。<br><br>flutter  build<br><br>列表或开关Flutter通道。<br><br>flutter channel<br><br>删除构建/目录。<br><br>flutter  clean<br><br>配置Flutter设置。<br><br>flutter config<br><br>创建一个新的Flutter项目。<br><br>flutter  create<br><br>列出所有连接的设备。 <br><br>flutter  devices<br><br>展示了有关安装工具的信息。<br><br>flutter doctor<br><br>为当前项目运行Flutter驱动程序测试。<br><br>flutter drive<br><br>格式一个或多个Dart文件。<br><br>flutter format<br><br>在Fuchsia上进行热重载。<br><br>flutter  fuchsia_reload<br><br>显示帮助信息的Flutter。<br><br>flutter help<br><br>在附加设备上安装Flutter应用程序。<br><br>flutter install<br><br>显示用于运行Flutter应用程序的日志输出。<br><br> flutter logs<br><br>命令用于管理Flutter包。<br><br>flutter packages<br><br>填充了Flutter工具的二进制工件缓存。<br><br>flutter  precache<br><br>在附加设备上运行你的Flutter应用程序。<br><br>flutter  run<br><br>从一个连接的设备截图。<br><br>flutter screenshot<br><br>停止在附加设备上的Flutter应用。<br><br>flutter stop<br><br>对当前项目的Flutter单元测试。<br><br>flutter test<br><br>开始并停止跟踪运行的Flutter应用程序。<br><br>flutter trace<br><br>升级你的Flutter副本。<br><br>flutter upgrade<br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些flutter开发遇到的问题和一些常用的flutter命令行，方便调试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记一些工具命令行（持续更新）</title>
    <link href="https://github.com/DJoeyZhang/archives/6f45ff58.html"/>
    <id>https://github.com/DJoeyZhang/archives/6f45ff58.html</id>
    <published>2020-03-26T06:53:48.000Z</published>
    <updated>2020-10-14T02:54:56.904Z</updated>
    
    <content type="html"><![CDATA[<h6 id="一、查看本地keystore文件（前提是有keystore的密码）"><a href="#一、查看本地keystore文件（前提是有keystore的密码）" class="headerlink" title="一、查看本地keystore文件（前提是有keystore的密码）"></a>一、查看本地keystore文件（前提是有keystore的密码）</h6><p>命令：keytool -list -v -keystore 目标文件路径<br></p><h6 id="二、查看三方应用或是系统应用签名"><a href="#二、查看三方应用或是系统应用签名" class="headerlink" title="二、查看三方应用或是系统应用签名"></a>二、查看三方应用或是系统应用签名</h6><p>右键apk解压，目标文件是META-INF文件夹中的CERT.RSA文件，通过命令keytool.exe命令查看证书信息。可以查看签名的MD5、SHA1、SHA256值及签名算法<br><br>命令：keytool -printcert -file 目标文件路径。</p><h6 id="三、内存检查命令"><a href="#三、内存检查命令" class="headerlink" title="三、内存检查命令:"></a>三、内存检查命令:</h6><p>cd /Users/joey/Library/Android/sdk/platform-tools</p><p>./hprof-conv -z /Users/joey/Desktop/memory/memory-20200819T180839.hprof /Users/joey/Desktop/me.hprof</p><h6 id="四、后台启动-jar"><a href="#四、后台启动-jar" class="headerlink" title="四、后台启动.jar"></a>四、后台启动.jar</h6><p>nohup java -jar spring-boot01-1.0-SNAPSHOT.jar &gt; log.file 2&gt;&amp;1 &amp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;一、查看本地keystore文件（前提是有keystore的密码）&quot;&gt;&lt;a href=&quot;#一、查看本地keystore文件（前提是有keystore的密码）&quot; class=&quot;headerlink&quot; title=&quot;一、查看本地keystore文件（前提是有keyst
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记录一些不错的博文(持续更新)</title>
    <link href="https://github.com/DJoeyZhang/archives/d68ca116.html"/>
    <id>https://github.com/DJoeyZhang/archives/d68ca116.html</id>
    <published>2020-03-07T15:06:00.000Z</published>
    <updated>2020-09-08T08:29:37.541Z</updated>
    
    <content type="html"><![CDATA[<p>博文而强识，温故而知新。这里记录一些平时看到的不错的文章。<br><br><a id="more"></a></p><p>1、关于Android Sqlite操作的文章，介绍的是Google官方的ROOM库，最近正好在做一个通讯录的需求用到。<br><br>Blog:<a href="https://www.jianshu.com/p/72c8efc3ad87" target="_blank" rel="noopener">https://www.jianshu.com/p/72c8efc3ad87</a><br>github:<a href="https://github.com/HoldMyOwn/RoomDemo">https://github.com/HoldMyOwn/RoomDemo</a><br>ROOM官方：<a href="https://developer.android.google.cn/jetpack/androidx/releases/room" target="_blank" rel="noopener">https://developer.android.google.cn/jetpack/androidx/releases/room</a></p><p>2、关于android应用静默升级，差分包前后端部署实现Blog:<a href="https://www.jianshu.com/p/058fd24bb2da" target="_blank" rel="noopener">https://www.jianshu.com/p/058fd24bb2da</a><br>github:<a href="https://github.com/itlwy/AppSmartUpdate">https://github.com/itlwy/AppSmartUpdate</a></p><p>3、关于OKhttp拦截器搭配retrofit使用<br>BLOG:<a href="https://www.jianshu.com/p/62ab11ddacc8" target="_blank" rel="noopener">https://www.jianshu.com/p/62ab11ddacc8</a></p><p>4、关于Room使用多表查询，建立关系型数据库<br><a href="https://www.jianshu.com/p/c7517ea16d1f" target="_blank" rel="noopener">https://www.jianshu.com/p/c7517ea16d1f</a></p><p>5、关于package.json中依赖版本配置:<br><a href="https://www.jianshu.com/p/e5959bf56844" target="_blank" rel="noopener">https://www.jianshu.com/p/e5959bf56844</a></p><p>6、关于HomeBrew源切换<br><a href="https://www.cnblogs.com/tulintao/p/11134877.html" target="_blank" rel="noopener">https://www.cnblogs.com/tulintao/p/11134877.html</a></p><p>7、关于kotlin携程的阐述<br><a href="https://blog.mindorks.com/mastering-kotlin-coroutines-in-android-step-by-step-guide" target="_blank" rel="noopener">https://blog.mindorks.com/mastering-kotlin-coroutines-in-android-step-by-step-guide</a></p><p>8、一个不错的博主，关于后端技术的博文:<br><a href="https://www.cnblogs.com/keeya/category/1255597.html" target="_blank" rel="noopener">https://www.cnblogs.com/keeya/category/1255597.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博文而强识，温故而知新。这里记录一些平时看到的不错的文章。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/DJoeyZhang/tags/android/"/>
    
      <category term="tools" scheme="https://github.com/DJoeyZhang/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>adb 常用命令（持续更新）</title>
    <link href="https://github.com/DJoeyZhang/archives/40bc90d3.html"/>
    <id>https://github.com/DJoeyZhang/archives/40bc90d3.html</id>
    <published>2020-02-11T10:00:00.000Z</published>
    <updated>2020-08-20T03:41:41.490Z</updated>
    
    <content type="html"><![CDATA[<h5 id="ADB-means-android-debug-bridge-是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。"><a href="#ADB-means-android-debug-bridge-是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。" class="headerlink" title="ADB means:android debug bridge,是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。"></a>ADB means:android debug bridge,是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。</h5><a id="more"></a><h5 id="1、http-proxy"><a href="#1、http-proxy" class="headerlink" title="1、http_proxy"></a>1、http_proxy</h5><p><b>设置代理：</b></p><p>adb shell settings put global http_proxy 代理IP地址:端口号</p><p>如：</p><p>adb shell settings put global http_proxy 127.0.0.1:8888</p><p><b>移除代理：</b></p><p>adb shell settings delete global http_proxy</p><p>adb shell settings delete global global_http_proxy_host</p><p>adb shell settings delete global global_http_proxy_port</p><p>adb reboot</p><p>但是，adb shell settings delete global http_proxy，再有些没有delete参数的设备上报错？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Invalid command: delete</span><br><span class="line"></span><br><span class="line">usage:  settings [--user NUM] get namespace key</span><br><span class="line"></span><br><span class="line">        settings [--user NUM] put namespace key value</span><br><span class="line"></span><br><span class="line">&apos;namespace&apos; is one of &#123;system, secure, global&#125;, case-insensitive</span><br><span class="line"></span><br><span class="line">If &apos;--user NUM&apos; is not given, the operations are performed on the owner user.</span><br></pre></td></tr></table></figure></p><p>解决方法，sqlite中找到settings.db,在数据库中删除代理信息（需要Root）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlite3 /data/data/com.android.providers.settings/databases/settings.db</span><br><span class="line">sqlite&gt; select * from global;</span><br><span class="line">sqlite&gt; delete from global where name=&quot;global_http_proxy_host&quot;;</span><br><span class="line">sqlite&gt; delete from global where name=&quot;global_http_proxy_port&quot;;</span><br><span class="line">sqlite&gt; delete from global where name=&quot;http_proxy&quot;;</span><br></pre></td></tr></table></figure></p><p>then adb rebbot</p><p><b>也可以使用第三方apk</b><br><br>AndroidProxySetter工具可以帮助我们使用adb命令可以快速进行wifi代理的设置和清除<br>GitHub地址：</p><p><a href="https://github.com/jpkrause/AndroidProxySetter">https://github.com/jpkrause/AndroidProxySetter</a><br>下好apk后，安装到手机</p><p>adb install proxy-setter-debug-0.2.1.apk</p><p>设置代理：</p><p>adb shell am start -n tk.elevenk.proxysetter/.MainActivity -e host 代理IP地址 -e port 端口号 -e ssid WIFI名称 -e reset-wifi true -e key WIFI密码</p><p>如：</p><p>adb shell am start -n tk.elevenk.proxysetter/.MainActivity -e host 127.0.0.1 -e port 8888 -e ssid YOUR-WIFI-NAME -e reset-wifi true -e key YOUR-WIFI-PASSWORD</p><h5 id="2、安装、卸载应用"><a href="#2、安装、卸载应用" class="headerlink" title="2、安装、卸载应用"></a>2、安装、卸载应用</h5><p><b>安装：</b><br><br>adb install com.xxx.xxx(包名)<br><br><b>卸载：</b><br><br>adb uninstall com.xxx.xxx(包名)</p><h5 id="3、调试应用"><a href="#3、调试应用" class="headerlink" title="3、调试应用"></a>3、调试应用</h5><p><b>抓日志：</b><br><br>adb logcat -v time &gt; ~\logcat.log<br></p><p><b>列出adb连接的设备:</b><br><br>adb devices</p><p><b>PC机连接某个电视盒子设备:</b><br><br>adb connect 192.168.1.19(连接某个设备，192.168.1.19是设备的IP地址，手机测试一般用不到，盒子或者电视设备会用到)</p><p><b>清除安装的APK缓存数据:</b><br><br>adb shell pm clear com.hiveview.tv（包名） <br><br>清除某个apk缓存数据，清空的是 /data/data/包名/ 下的数据，包括数据库文件等</p><p><b>查看APK包名版本信息:</b><br><br>aapt dump badging pc上apk路径地址<br><br>查看某个apk（在Android系统中包名（例如格式：com.hiveview.tv）是唯一标示一个应用的ID）</p><p><b>shell模式:</b><br><br>命令窗口 adb shell 是进入Linux命令模式了，进入此模式之后，ls，cd ,rm 等命令都可用使用了.</p><p><b>把本地文件放到设备端:</b><br><br>adb push D:\file.txt system/        <br><br>file.text是本地文件<br><br>system是设备路径</p><p><b>把设备端文件放置到本地电脑:</b><br><br>adb pull system/file.txt D:/<br><br>system/file.text是设备上的文件<br><br>D:/是本地路径</p><p><b>截屏:</b><br><br>adb shell 进入linux命令模式 <br><br>执行screencap -p /data/app/1.png 截屏，截屏的图片1.png即在/data/app文件夹下了</p><p><b>发送广播的命令:</b><br><br>adb shell am broadcast -a com.android.test –es test_string “this is test string” –ei test_int 100 –ez test_boolean true</p><p>－es 是传递String参数，test_string 参数key    “this is test string” 是参数值</p><p>－ei 是传递int参数，test_int 参数key    10 是参数值 </p><p>－ez 是传递boolean参数，test_boolean 参数key    true是参数值</p><p><b>启动某个activity:</b><br><br>am start -n 包(package)名/包名.活动(activity)名称启动 <br><br>云屏默认设置：am start com.android.settings/.Settings<br><br>后跟 –es 可以传递参数</p><p><b>挂载某个目录:</b><br><br>mount －o remount   /system<br>挂载某个目录，如果命令行提示文件只有读权限，建议执行此命令挂一下此目录</p><p><b>查看内存使用情况:</b><br><br>adb shell  模式下：cat /proc/meminfo <br><br>详情解释:<a href="http://www.jbxue.com/LINUXjishu/9930.html" target="_blank" rel="noopener">http://www.jbxue.com/LINUXjishu/9930.html</a></p><p>MemTotal: 所有可用RAM大小（即物理内存减去一些预留位和内核的二进制代码大小）<br><br>MemFree: LowFree与HighFree的总和，被系统留着未使用的内存<br><br>Buffers: 用来给文件做缓冲大小<br><br>Cached: 被高速缓冲存储器（cache memory）用的内存的大小（等于 diskcache minus SwapCache ）.<br><br>SwapCached:被高速缓冲存储器（cache memory）用的交换空间的大小<br>           已经被交换出来的内存，但仍然被存放在swapfile中。用来在需要的时候很快的被替换而不需要再次打开I/O端口。 <br><br>Active: 在活跃使用中的缓冲或高速缓冲存储器页面文件的大小，除非非常必要否则不会被移作他用.<br><br>Inactive: 在不经常使用中的缓冲或高速缓冲存储器页面文件的大小，可能被用于其他途径.<br><br>HighTotal\HighFree: 该区域不是直接映射到内核空间。内核必须使用不同的手法使用该段内存。<br><br>LowTotal\LowFree: 低位可以达到高位内存一样的作用，而且它还能够被内核用来记录一些自己的数据结构。<br><br>SwapTotal: 交换空间的总大小<br><br>SwapFree: 未被使用交换空间的大小<br><br>Dirty: 等待被写回到磁盘的内存大小。<br><br>Writeback: 正在被写回到磁盘的内存大小。<br><br>AnonPages：未映射页的内存大小<br><br>Mapped: 设备和文件等映射的大小。<br><br>Slab: 内核数据结构缓存的大小，可以减少申请和释放内存带来的消耗。<br><br>SReclaimable:可收回Slab的大小<br><br>SUnreclaim：不可收回Slab的大小（SUnreclaim+SReclaimable＝Slab）<br><br>PageTables：管理内存分页页面的索引表的大小。<br><br>NFS_Unstable:不稳定页表的大小<br><br>VmallocTotal: 可以vmalloc虚拟内存大小<br><br>VmallocUsed: 已经被使用的虚拟内存大小。<br><br>VmallocChunk: largest contigious block of vmalloc area which is free</p><p><b>命令行模拟遥控器按键:</b><br><br>adb shell 进入命令模式下：input keyevent  keycode值 如：</p><p>input keyevent 4 相当于按了返回键</p><p>input keyevent 82 模拟菜单键</p><p>input keyevent 3 主页键</p><p>input keyevent 19 按上键</p><p>input keyevent 20 按下键</p><p>input keyevent 21 按左键</p><p>input keyevent 22 按右键</p><p>input keyevent 23 按确定键</p><p><b>刷ROM命令:</b><br><br>adb connect IP 连接上盒子或者电视，盒子上插上带ROM的U盘，命令窗口输入 </p><p>adb reboot recovery，之后盒子重启会直接读取ROM文件进行刷机了</p><p>串口TTL：pm list packages 查看已安装应用</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;ADB-means-android-debug-bridge-是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。&quot;&gt;&lt;a href=&quot;#ADB-means-android-debug-bridge-是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。&quot; class=&quot;headerlink&quot; title=&quot;ADB means:android debug bridge,是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。&quot;&gt;&lt;/a&gt;ADB means:android debug bridge,是调试Android设备的桥。开发电视经常需要敲一些adb命令，这里收藏一些常用的ADB命令。&lt;/h5&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/DJoeyZhang/tags/android/"/>
    
      <category term="tools" scheme="https://github.com/DJoeyZhang/tags/tools/"/>
    
  </entry>
  
</feed>
