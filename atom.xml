<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>权译&#39;s  Blog</title>
  
  <subtitle>记录生活点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/DJoeyZhang/"/>
  <updated>2022-04-06T04:14:07.619Z</updated>
  <id>https://github.com/DJoeyZhang/</id>
  
  <author>
    <name>权译</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>type 与 interface 的区别，你真的懂了吗？</title>
    <link href="https://github.com/DJoeyZhang/archives/1a30af01.html"/>
    <id>https://github.com/DJoeyZhang/archives/1a30af01.html</id>
    <published>2022-04-06T04:04:05.000Z</published>
    <updated>2022-04-06T04:14:07.619Z</updated>
    
    <content type="html"><![CDATA[<p>在写 ts 相关代码的过程中，总能看到 interface 和 type 的身影。它们的作用好像都一样的，相同的功能用哪一个都可以实现，也都很好用，所以也很少去真正的理解它们之间到底有啥区别， 分别在什么场景下使用，将自己学习的内容记录分享一下</p><h4 id="类型别名-type"><a href="#类型别名-type" class="headerlink" title="类型别名 type"></a>类型别名 type</h4><p>首先认识一下什么是类型别名？<br><br>类型别名用来给一个类型起个新名字，使用 type 创建类型别名，类型别名不仅可以用来表示基本类型，还可以用来表示对象类型、联合类型、元组和交集。让我们看一些例子：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type userName = string; // 基本类型</span><br><span class="line">type userId = string | number; // 联合类型</span><br><span class="line">type arr = number[]; </span><br><span class="line"></span><br><span class="line">// 对象类型</span><br><span class="line">type Person = &#123;</span><br><span class="line">    id: userId; // 可以使用定义类型</span><br><span class="line">    name: userName;</span><br><span class="line">    age: number;</span><br><span class="line">    gender: string;</span><br><span class="line">    isWebDev: boolean;</span><br><span class="line">&#125;;</span><br><span class="line">// 范型</span><br><span class="line">type Tree&lt;T&gt; = &#123; value: T &#125;;</span><br><span class="line"></span><br><span class="line">const user: Person = &#123;</span><br><span class="line">    id: &quot;901&quot;,</span><br><span class="line">    name: &quot;椿&quot;,</span><br><span class="line">    age: 22,</span><br><span class="line">    gender: &quot;女&quot;,</span><br><span class="line">    isWebDev: false,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const numbers: arr = [1, 8, 9];</span><br></pre></td></tr></table></figure></p><h4 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h4><p>接口是命名数据结构（例如对象）的另一种方式；与type 不同，interface仅限于描述对象类型。<br><br>接口的声明语法也不同于类型别名的声明语法。让我们将上面的类型别名 Person 重写为接口声明：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    id: userId;</span><br><span class="line">    name: userName;</span><br><span class="line">    age: number;</span><br><span class="line">    gender: string;</span><br><span class="line">    isWebDev: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="interface和type的相似之处"><a href="#interface和type的相似之处" class="headerlink" title="interface和type的相似之处"></a>interface和type的相似之处</h4><p>在讨论二者区别之前， 首先看一下二者的相似之处（为何开发中，我们觉得用哪个都一样）</p><h6 id="都可以描述-Object和Function"><a href="#都可以描述-Object和Function" class="headerlink" title="都可以描述 Object和Function"></a>都可以描述 Object和Function</h6><p>两者都可以用来描述对象或函数,但语法不同:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Type</span><br><span class="line">type Point = &#123;</span><br><span class="line">  x: number;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type SetPoint = (x: number, y: number) =&gt; void;</span><br><span class="line">Interface</span><br><span class="line">interface Point &#123;</span><br><span class="line">  x: number;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SetPoint &#123;</span><br><span class="line">  (x: number, y: number): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="二者都可以被继承"><a href="#二者都可以被继承" class="headerlink" title="二者都可以被继承"></a>二者都可以被继承</h6><p>interface 和 type 都可以继承。<br><br>另一个值得注意的是，接口和类型别名并不互斥。类型别名可以继承接口，反之亦然。只是在实现形式上，稍微有些差别。<br><br>interface 继承 interface<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Person&#123;</span><br><span class="line">    name:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Student extends Person &#123; stuNo: number &#125;</span><br></pre></td></tr></table></figure></p><p>interface 继承 type<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Person&#123;</span><br><span class="line">    name:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Student extends Person &#123; stuNo: number &#125;</span><br></pre></td></tr></table></figure></p><p>type 继承 type<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Person&#123;</span><br><span class="line">    name:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student = Person &amp; &#123; stuNo: number &#125;</span><br></pre></td></tr></table></figure></p><p>type 继承 interface<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Person&#123;</span><br><span class="line">    name:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student = Person &amp; &#123; stuNo: number &#125;</span><br></pre></td></tr></table></figure></p><p>实现 implements</p><p>类可以实现interface 以及 type(除联合类型外)<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface ICat&#123;</span><br><span class="line">    setName(name:string): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat implements ICat&#123;</span><br><span class="line">    setName(name:string):void&#123;</span><br><span class="line">        // todo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// type </span><br><span class="line">type ICat = &#123;</span><br><span class="line">    setName(name:string): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat implements ICat&#123;</span><br><span class="line">    setName(name:string):void&#123;</span><br><span class="line">        // todo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面提到了特殊情况，类无法实现联合类型, 是什么意思呢？<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Person = &#123; name: string; &#125; | &#123; setName(name:string): void &#125;;</span><br><span class="line"></span><br><span class="line">// 无法对联合类型Person进行实现</span><br><span class="line">// error: A class can only implement an object type or intersection of object types with statically known members.</span><br><span class="line">class Student implements Person &#123;</span><br><span class="line">  name= &quot;张三&quot;;</span><br><span class="line">  setName(name:string):void&#123;</span><br><span class="line">        // todo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面聊了interface与 type的相似之处， 接下来就来看看他们的区别。</p><h6 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h6><ol><li>定义基本类型别名</li></ol><p>type可以定义基本类型别名, 但是interface无法定义,如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type userName = string</span><br><span class="line">type stuNo = number</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><ol start="2"><li>声明联合类型</li></ol><p>type可以声明联合类型, 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Student = &#123;stuNo: number&#125; | &#123;classId: number&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>声明元组</li></ol><p>type可以声明 元组类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Data = [number, string];</span><br></pre></td></tr></table></figure></p><p>以上都是 type能做到， 而interface做不到的， 接下来聊聊type做不到的</p><ol start="4"><li>声明合并</li></ol><p>如果你多次声明一个同名的接口，TypeScript 会将它们合并到一个声明中，并将它们视为一个接口。这称为声明合并， 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123; name: string &#125;</span><br><span class="line">interface Person &#123; age: number &#125;</span><br><span class="line"></span><br><span class="line">let user: Person = &#123;</span><br><span class="line">    name: &quot;Tolu&quot;,</span><br><span class="line">    age: 0,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这种情况下，如果是type的话，重复使用Person是会报错的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Person &#123; name: string &#125;; </span><br><span class="line"></span><br><span class="line">// Error: 标识符“Person”重复。ts(2300)</span><br><span class="line">type Person &#123; age: number &#125;</span><br></pre></td></tr></table></figure></p><h6 id="5-索引签名问题"><a href="#5-索引签名问题" class="headerlink" title="5. 索引签名问题"></a>5. 索引签名问题</h6><p>如果你经常使用TypeScript, 一定遇到过相似的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type &apos;xxx&apos; is not assignable to type &apos;yyy&apos;</span><br><span class="line">Index signature is missing in type &apos;xxx&apos;.</span><br></pre></td></tr></table></figure></p><p>看个例子来理解问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface propType&#123;</span><br><span class="line">    [key: string] : string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let props: propType</span><br><span class="line"></span><br><span class="line">type dataType = &#123;</span><br><span class="line">    title: string</span><br><span class="line">&#125;</span><br><span class="line">interface dataType1 &#123;</span><br><span class="line">    title: string</span><br><span class="line">&#125;</span><br><span class="line">const data: dataType = &#123;title: &quot;订单页面&quot;&#125;</span><br><span class="line">const data1: dataType1 = &#123;title: &quot;订单页面&quot;&#125;</span><br><span class="line">props = data</span><br><span class="line">// Error:类型“dataType1”不可分配给类型“propType”; 类型“dataType1”中缺少索引签名 </span><br><span class="line">props = data1</span><br></pre></td></tr></table></figure></p><p>我们发现dataType和dataType1对应的类型一样，但是interface定义的就赋值失败，是什么原因呢？刚开始百思不解，最后我在 stack overflow上找到了一个相似的问题：<br><br>并且很幸运的找到了有效的答案：<br><br><br>翻译过来的大致意思就是：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Record&lt;string,string&gt;与&#123;[key:string]：string&#125;相同。只有当该类型的所有属性都已知并且可以对照该索引签名进行检查时，才允许将子集分配给该索引签名类型。在您的例子中，从exampleType到Record&lt;string,string&gt;的所有内容都是可分配的。这只能针对对象字面量类型进行检查，因为一旦声明了对象字面量类型，就无法更改它们。因此，索引签名是已知的。</span><br><span class="line">相反，在你使用interface去声明变量时，它们在那一刻类型并不是最终的类型。由于interfac可以进行声明合并，所以总有可能将新成员添加到同一个interface定义的类型上。</span><br></pre></td></tr></table></figure></p><p>再结合👆第4点 声明合并的讲解, 这样就很好理解了。就是说interface定义的类型是不确定的， 后面再来一个：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface propType&#123;</span><br><span class="line">    title:number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样propType类型就被改变了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>官方推荐用 interface，其他无法满足需求的情况下用 type。<br><br>但其实，因为 联合类型 和 交叉类型 是很常用的，所以避免不了大量使用 type 的场景，一些复杂类型也需要通过组装后形成类型别名来使用。<br><br>所以，如果想保持代码统一，还是可选择使用 type。通过上面的对比，类型别名 其实可涵盖 interface 的大部分场景。<br><br>对于 React 组件中 props及 state，使用 type ，这样能够保证使用组件的地方不能随意在上面添加属性。如果有自定义需求，可通过 HOC二次封装。<br><br>编写三方库时使用interface，其更加灵活自动的类型合并可应对未知的复杂使用场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在写 ts 相关代码的过程中，总能看到 interface 和 type 的身影。它们的作用好像都一样的，相同的功能用哪一个都可以实现，也都很好用，所以也很少去真正的理解它们之间到底有啥区别， 分别在什么场景下使用，将自己学习的内容记录分享一下&lt;/p&gt;
&lt;h4 id=&quot;类型
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web开发的一些面试题</title>
    <link href="https://github.com/DJoeyZhang/archives/7f76ef76.html"/>
    <id>https://github.com/DJoeyZhang/archives/7f76ef76.html</id>
    <published>2021-06-18T06:47:40.000Z</published>
    <updated>2021-06-21T04:10:01.165Z</updated>
    
    <content type="html"><![CDATA[<p>这次记一些面试题总结，给自己用。<br><br><a id="more"></a><br>一、Vue and React<br><br>1、Vue底层原理<br><br>基于MVVM设计，双向绑定:发布者－订阅者模式,Object.defineProperty()数据劫持。<br><a href="https://www.jianshu.com/p/5990a386132a" target="_blank" rel="noopener">https://www.jianshu.com/p/5990a386132a</a></p><p>2、webpack一些配置，删除无用代码原理，chunk如何加载，摇树，runtime<br><br>通过分析静态的ES模块，来剔除未使用代码的。<br><br>webpack –config webpack.config.js<br><br>chunk动态加载：<a href="https://www.cnblogs.com/dahe1989/p/11543832.html" target="_blank" rel="noopener">https://www.cnblogs.com/dahe1989/p/11543832.html</a><br><br>webpack打包去除无用代码：<a href="https://www.cnblogs.com/maycpou/p/14560116.html" target="_blank" rel="noopener">https://www.cnblogs.com/maycpou/p/14560116.html</a></p><p>3、手写promise<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">class WPromise &#123;</span><br><span class="line">    static pending = &apos;pending&apos;;</span><br><span class="line">    static fulfilled = &apos;fulfilled&apos;;</span><br><span class="line">    static rejected = &apos;rejected&apos;;</span><br><span class="line"></span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        this.status = WPromise.pending; // 初始化状态为pending</span><br><span class="line">        this.value = undefined; // 存储 this._resolve 即操作成功 返回的值</span><br><span class="line">        this.reason = undefined; // 存储 this._reject 即操作失败 返回的值</span><br><span class="line">        // 存储then中传入的参数</span><br><span class="line">        // 至于为什么是数组呢？因为同一个Promise的then方法可以调用多次</span><br><span class="line">        this.callbacks = [];</span><br><span class="line">        executor(this._resolve.bind(this), this._reject.bind(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // onFulfilled 是成功时执行的函数</span><br><span class="line">    // onRejected 是失败时执行的函数</span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        // 返回一个新的Promise</span><br><span class="line">        return new WPromise((nextResolve, nextReject) =&gt; &#123;</span><br><span class="line">            // 这里之所以把下一个Promsie的resolve函数和reject函数也存在callback中</span><br><span class="line">            // 是为了将onFulfilled的执行结果通过nextResolve传入到下一个Promise作为它的value值</span><br><span class="line">            this._handler(&#123;</span><br><span class="line">                nextResolve,</span><br><span class="line">                nextReject,</span><br><span class="line">                onFulfilled,</span><br><span class="line">                onRejected</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _resolve(value) &#123;</span><br><span class="line">        // 处理onFulfilled执行结果是一个Promise时的情况</span><br><span class="line">        // 这里可能理解起来有点困难</span><br><span class="line">        // 当value instanof WPromise时，说明当前Promise肯定不会是第一个Promise</span><br><span class="line">        // 而是后续then方法返回的Promise（第二个Promise）</span><br><span class="line">        // 我们要获取的是value中的value值（有点绕，value是个promise时，那么内部存有个value的变量）</span><br><span class="line">        // 怎样将value的value值获取到呢，可以将传递一个函数作为value.then的onFulfilled参数</span><br><span class="line">        // 那么在value的内部则会执行这个函数，我们只需要将当前Promise的value值赋值为value的value即可</span><br><span class="line">        if (value instanceof WPromise) &#123;</span><br><span class="line">            value.then(</span><br><span class="line">                this._resolve.bind(this),</span><br><span class="line">                this._reject.bind(this)</span><br><span class="line">            );</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.value = value;</span><br><span class="line">        this.status = WPromise.fulfilled; // 将状态设置为成功</span><br><span class="line"></span><br><span class="line">        // 通知事件执行</span><br><span class="line">        this.callbacks.forEach(cb =&gt; this._handler(cb));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _reject(reason) &#123;</span><br><span class="line">        if (reason instanceof WPromise) &#123;</span><br><span class="line">            reason.then(</span><br><span class="line">                this._resolve.bind(this),</span><br><span class="line">                this._reject.bind(this)</span><br><span class="line">            );</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.reason = reason;</span><br><span class="line">        this.status = WPromise.rejected; // 将状态设置为失败</span><br><span class="line"></span><br><span class="line">        this.callbacks.forEach(cb =&gt; this._handler(cb));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _handler(callback) &#123;</span><br><span class="line">        const &#123;</span><br><span class="line">            onFulfilled,</span><br><span class="line">            onRejected,</span><br><span class="line">            nextResolve,</span><br><span class="line">            nextReject</span><br><span class="line">        &#125; = callback;</span><br><span class="line"></span><br><span class="line">        if (this.status === WPromise.pending) &#123;</span><br><span class="line">            this.callbacks.push(callback);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.status === WPromise.fulfilled) &#123;</span><br><span class="line">            // 传入存储的值</span><br><span class="line">            // 未传入onFulfilled时，value传入</span><br><span class="line">            const nextValue = onFulfilled</span><br><span class="line">                ? onFulfilled(this.value)</span><br><span class="line">                : this.value;</span><br><span class="line">            nextResolve(nextValue);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.status === WPromise.rejected) &#123;</span><br><span class="line">            // 传入存储的错误信息</span><br><span class="line">            // 同样的处理</span><br><span class="line">            const nextReason = onRejected</span><br><span class="line">                ? onRejected(this.reason)</span><br><span class="line">                : this.reason;</span><br><span class="line">            nextReject(nextReason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、封装fetch<br><br>接上一个Promise实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 模拟一个简单的异步行为 */</span><br><span class="line">function fetchData() &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            resolve(&apos;willem&apos;);</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetchData().then((data) =&gt; &#123;</span><br><span class="line">    // after 1000ms</span><br><span class="line">    console.log(data); // willem</span><br><span class="line">    return &apos;wei&apos;;</span><br><span class="line">&#125;, (err) =&gt; &#123;&#125;).then((data2) =&gt; &#123;</span><br><span class="line">    console.log(data2); // wei</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>5、es6转es5原理<br><br>(1)parse<br><br>第一步主要是将 ES6 语法解析为 AST 抽象语法树。简单地说就是将代码打散成颗粒组装的对象。这一步主要是通过 babylon 插件来完成<br><br>(2)transfrom<br><br>第二步是将打散的 AST 语法通过配置好的 plugins（babel-traverse 对 AST 进行遍历转译）和 presets （es2015 / es2016 / es2017 / env / stage-0 / stage-4 其中 es20xx 表示转换成该年份批准的标准，env 是最新标准，stage-0 和 stage-4 是实验版）转换成新的 AST 语法。这一步主要是由 babel-transform 插件完成。plugins 和 presets 通常在 .babelrc 文件中配置。<br><br>(3)Generator<br><br>第三步是将新的 AST 语法树对象再生成浏览器都可以识别的 ES5 语法。这一步主要是由 babel-generator 插件完成。<br><br><a href="https://blog.csdn.net/weixin_44135121/article/details/104161852" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44135121/article/details/104161852</a></p><p>6、手写函数curry,闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 普通的add函数</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Currying后</span><br><span class="line">function curryingAdd(x) &#123;</span><br><span class="line">    return function (y) &#123;</span><br><span class="line">        return x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 2)           // 3</span><br><span class="line">curryingAdd(1)(2)   // 3</span><br></pre></td></tr></table></figure></p><p>curry：<a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">https://www.jianshu.com/p/2975c25e4d71</a><br><br>闭包：<a href="https://www.jianshu.com/p/9eb30b6af3a1" target="_blank" rel="noopener">https://www.jianshu.com/p/9eb30b6af3a1</a></p><p>7、手写前序遍历、中序遍历、快排<br><br><a href="https://www.cnblogs.com/echolun/p/13328927.html" target="_blank" rel="noopener">https://www.cnblogs.com/echolun/p/13328927.html</a></p><p>8、vue路由原理，路由守卫<br><br>路由原理：<a href="https://www.cnblogs.com/gaosirs/p/10606266.html" target="_blank" rel="noopener">https://www.cnblogs.com/gaosirs/p/10606266.html</a><br><br>路由守卫：<a href="https://www.jianshu.com/p/691379025334" target="_blank" rel="noopener">https://www.jianshu.com/p/691379025334</a></p><p>9、react hook相关<br><br><a href="https://blog.csdn.net/kellywong/article/details/106430977" target="_blank" rel="noopener">https://blog.csdn.net/kellywong/article/details/106430977</a></p><p>10、如何优化，前端错误监控<br><br>数据采集-&gt;上报-&gt;服务处理-&gt;数据存储-&gt;可视化<br><br><a href="https://segmentfault.com/a/1190000021029136" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021029136</a></p><p>11、vue和react框架比较<br><br>二者都通过虚拟DOM，在渲染之前进行domDiff操作，降低了dom 频繁操作的成本，<br><br>vue 的模版语法对初学者较容易上手<br></p><p>12、webpack进行css-less打包<br><br><a href="https://www.jianshu.com/p/218ecf81c07b" target="_blank" rel="noopener">https://www.jianshu.com/p/218ecf81c07b</a></p><p>二、浏览器相关<br><br>1、浏览器存储方式有什么<br><br>Cookie、localStorage、 sessionStorage<br><br><a href="https://www.cnblogs.com/jing-tian/p/10991431.html" target="_blank" rel="noopener">https://www.cnblogs.com/jing-tian/p/10991431.html</a></p><p>2、LS的limit一般浏览器限制多少<br><br>5M,cookie较小，一般4k<br></p><p>3、如果LS做缓存层有什么方案保证不溢出<br><br>LRU</p><p>4、LRU实现<br><br><a href="https://www.cnblogs.com/everlose/p/12854807.html" target="_blank" rel="noopener">https://www.cnblogs.com/everlose/p/12854807.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var LRUCache = function (capacity) &#123;</span><br><span class="line">  this.cache = new Map();</span><br><span class="line">  this.capacity = capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.get = function (key) &#123;</span><br><span class="line">  if (this.cache.has(key)) &#123;</span><br><span class="line">    // 存在即更新</span><br><span class="line">    let temp = this.cache.get(key);</span><br><span class="line">    this.cache.delete(key);</span><br><span class="line">    this.cache.set(key, temp);</span><br><span class="line">    return temp;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LRUCache.prototype.put = function (key, value) &#123;</span><br><span class="line">  if (this.cache.has(key)) &#123;</span><br><span class="line">    // 存在即更新（删除后加入）</span><br><span class="line">    this.cache.delete(key);</span><br><span class="line">  &#125; else if (this.cache.size &gt;= this.capacity) &#123;</span><br><span class="line">    // 不存在即加入</span><br><span class="line">    // 缓存超过最大值，则移除最近没有使用的</span><br><span class="line">    this.cache.delete(this.cache.keys().next().value);</span><br><span class="line">  &#125;</span><br><span class="line">  this.cache.set(key, value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>5、浏览器输入url到页面呈现过程<br><br>DNS 解析 -&gt; 三次握手 -&gt;建立TCP连接后发起http请求 -&gt;服务器收到请求并响应HTTP请求 -&gt;浏览器解析htm代码,并请求htm代码中的资源(如js、css图片等) -&gt; 断开TCP连接<br>(四次挥手)-&gt;浏览器对页面进行渲染呈现给用户<br><br><a href="https://blog.csdn.net/qq_21993785/article/details/81188253" target="_blank" rel="noopener">https://blog.csdn.net/qq_21993785/article/details/81188253</a></p><p>三、微前端<br><br>1、样式隔离<br><br><a href="https://www.yuque.com/techiu/vkrpan/urz482" target="_blank" rel="noopener">https://www.yuque.com/techiu/vkrpan/urz482</a><br>2、路由同步<br><br>3、JS沙箱<br><br>4、低代码<br></p><p>四、Flutter相关<br><br>1、<a href="https://www.jianshu.com/p/93821c12a825" target="_blank" rel="noopener">https://www.jianshu.com/p/93821c12a825</a><br><br>2、<a href="https://zhuanlan.zhihu.com/p/102193331" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102193331</a><br><br>3、<a href="https://www.jianshu.com/p/1e00b5aaf422" target="_blank" rel="noopener">https://www.jianshu.com/p/1e00b5aaf422</a><br><br>4、<a href="https://blog.csdn.net/u013095264/article/details/88802822" target="_blank" rel="noopener">https://blog.csdn.net/u013095264/article/details/88802822</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次记一些面试题总结，给自己用。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>web开发中碰到的一些问题记录和不错的文章</title>
    <link href="https://github.com/DJoeyZhang/archives/430ebcc9.html"/>
    <id>https://github.com/DJoeyZhang/archives/430ebcc9.html</id>
    <published>2021-05-31T09:12:21.000Z</published>
    <updated>2021-11-30T07:33:32.112Z</updated>
    
    <content type="html"><![CDATA[<p>1、关闭Mac Chrome 跨域追踪：</p><p>open -n /Applications/Google\ Chrome.app/ –args –disable-web-security –user-data-dir=/Users/xxx/Documents/chromeDevData</p><p>2、第三方免密认证登录过程中使用跨域set-Cookie方式在IOS上引发的问题：<br><a href="https://www.dazhuanlan.com/2019/10/26/5db45ddb1e269/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/10/26/5db45ddb1e269/</a></p><p>3、修改数据库默认密码，查看mysql运行端口：<br>UPDATE user SET password=password(“xxx”) WHERE user=’xxx’;<br>ps -ef | grep -i mysql</p><p>4、一些CSS常用：<br><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651578836&amp;idx=3&amp;sn=ca591c6c4d0d28a5e61a76ba635abe91&amp;chksm=80253615b752bf031a7384ea2bf57ace6bb0d4069d51dcc96636540ff10df5e4c323764025d0&amp;mpshare=1&amp;scene=1&amp;srcid=0725gVlIhi20eCf77NAXBXxt&amp;sharer_sharetime=1627185735184&amp;sharer_shareid=be21b1929d4663aea6a803efa48d5e90#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651578836&amp;idx=3&amp;sn=ca591c6c4d0d28a5e61a76ba635abe91&amp;chksm=80253615b752bf031a7384ea2bf57ace6bb0d4069d51dcc96636540ff10df5e4c323764025d0&amp;mpshare=1&amp;scene=1&amp;srcid=0725gVlIhi20eCf77NAXBXxt&amp;sharer_sharetime=1627185735184&amp;sharer_shareid=be21b1929d4663aea6a803efa48d5e90#rd</a></p><p>5、ADDEVENTLISTENER（TYPE, FN , TRUE/FALSE）绑定事件第三个参数作用以及利用事件的冒泡，实现事件委托<br><br><a href="https://www.freesion.com/article/69361257443/" target="_blank" rel="noopener">https://www.freesion.com/article/69361257443/</a></p><p>6、经常使用JSON.stringify()。你知道第二个和第三个参数是做什么的吗？<br><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651578711&amp;idx=1&amp;sn=66987b91ed5b35d20bb40a7c9292fb8e&amp;chksm=80253696b752bf8082ef3cd4aa17bf5979e54492277b4ebfe4e19c7fda98acb7b82d7ac59124&amp;mpshare=1&amp;scene=1&amp;srcid=0720LvbBw4xcO9oo7tecLvSC&amp;sharer_sharetime=1626762380117&amp;sharer_shareid=be21b1929d4663aea6a803efa48d5e90#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651578711&amp;idx=1&amp;sn=66987b91ed5b35d20bb40a7c9292fb8e&amp;chksm=80253696b752bf8082ef3cd4aa17bf5979e54492277b4ebfe4e19c7fda98acb7b82d7ac59124&amp;mpshare=1&amp;scene=1&amp;srcid=0720LvbBw4xcO9oo7tecLvSC&amp;sharer_sharetime=1626762380117&amp;sharer_shareid=be21b1929d4663aea6a803efa48d5e90#rd</a></p><p>7、36个web开发中常见的问题（很系统）<br><a href="https://segmentfault.com/a/1190000040896436" target="_blank" rel="noopener">https://segmentfault.com/a/1190000040896436</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、关闭Mac Chrome 跨域追踪：&lt;/p&gt;
&lt;p&gt;open -n /Applications/Google\ Chrome.app/ –args –disable-web-security –user-data-dir=/Users/xxx/Documents/chr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter相关博文</title>
    <link href="https://github.com/DJoeyZhang/archives/3102f069.html"/>
    <id>https://github.com/DJoeyZhang/archives/3102f069.html</id>
    <published>2021-04-26T06:57:54.000Z</published>
    <updated>2021-04-26T06:58:00.733Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用flutter重构来话应用。期间参考的一些不错的资料，记录下来。<br><a id="more"></a><br>1、flutter轮子大全：<br><a href="https://pub.dev/flutter/packages" target="_blank" rel="noopener">https://pub.dev/flutter/packages</a></p><p>2、关于flutter的布局讲解：<br><a href="https://www.cnblogs.com/lxlx1798/p/11084904.html" target="_blank" rel="noopener">https://www.cnblogs.com/lxlx1798/p/11084904.html</a></p><p>3、Flutter多渠道打包：<br><a href="https://juejin.cn/post/6949901619689586719" target="_blank" rel="noopener">https://juejin.cn/post/6949901619689586719</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用flutter重构来话应用。期间参考的一些不错的资料，记录下来。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>centos折腾confluence攻略</title>
    <link href="https://github.com/DJoeyZhang/archives/a144d083.html"/>
    <id>https://github.com/DJoeyZhang/archives/a144d083.html</id>
    <published>2021-04-26T06:55:51.000Z</published>
    <updated>2021-04-26T06:55:51.791Z</updated>
    
    <content type="html"><![CDATA[<p>团队还在刀耕火种，各种word文档满天飞，实在不能忍，于是在测试服务器上折腾了一个confluence方便团队协作。<br><a id="more"></a></p><h5 id="先提炼几个经常用的命令"><a href="#先提炼几个经常用的命令" class="headerlink" title="先提炼几个经常用的命令"></a>先提炼几个经常用的命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动wiki&lt;br&gt;</span><br><span class="line">/etc/init.d/confluence start</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">停止wiki服务&lt;br&gt;</span><br><span class="line">/etc/init.d/confluence stop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重启服务&lt;br&gt;</span><br><span class="line">/etc/init.d/confluence restart</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">卸载&lt;br&gt;</span><br><span class="line">/etc/init.d/confluence stop</span><br><span class="line">/opt/atlassian/confluence/uninstall</span><br><span class="line">rm -rf /opt/atlassian</span><br><span class="line">rm -rf /var/atlassian</span><br><span class="line">drop database wiki //登录数据库&lt;br&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据库设置</span><br><span class="line">jdbc:mysql://localhost:3306/wiki_new?useUnicode=true&amp;amp;characterEncoding=UTF8&amp;amp;sessionVariables=tx_isolation=&apos;READ-COMMITTED&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all on wiki_new.* to wiki_user@&quot;%&quot; identified by &quot;wiki_password&quot;;</span><br></pre></td></tr></table></figure><h5 id="关于confluence存储原理，方便迁移"><a href="#关于confluence存储原理，方便迁移" class="headerlink" title="关于confluence存储原理，方便迁移"></a>关于confluence存储原理，方便迁移</h5><p><a href="https://zhuanlan.zhihu.com/p/38625186" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38625186</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --delete /var/atlassian/ /confluence/atlassian/</span><br></pre></td></tr></table></figure></p><h5 id="发现一个更好的部署方案"><a href="#发现一个更好的部署方案" class="headerlink" title="发现一个更好的部署方案"></a>发现一个更好的部署方案</h5><p>1、<a href="https://www.dqzboy.com/atlassian%e5%85%a8%e5%ae%b6%e6%a1%b6%e4%bb%a5%e5%8f%8a%e6%8f%92%e4%bb%b6%e7%a0%b4%e8%a7%a3%e8%af%a6%e7%bb%86%e6%95%99%e7%a8%8b" target="_blank" rel="noopener">https://www.dqzboy.com/atlassian%e5%85%a8%e5%ae%b6%e6%a1%b6%e4%bb%a5%e5%8f%8a%e6%8f%92%e4%bb%b6%e7%a0%b4%e8%a7%a3%e8%af%a6%e7%bb%86%e6%95%99%e7%a8%8b</a></p><p>2、开源破解：<a href="https://zhile.io/2018/12/20/atlassian-license-crack.html" target="_blank" rel="noopener">https://zhile.io/2018/12/20/atlassian-license-crack.html</a></p><h5 id="好了，征文开始"><a href="#好了，征文开始" class="headerlink" title="好了，征文开始"></a>好了，征文开始</h5><p>系统：本机MacOS远程向CentOS6.6服务器安装wiki</p><p>wiki版本：5.4.4</p><p>文件：<a href="http://www.fengyachao.com/file/confluence.zip" target="_blank" rel="noopener">www.fengyachao.com/file/confluence.zip</a></p><p>开始</p><p>0.下载文件并解压，将下载的压缩文件上传到CentOS，解压缩</p><p>1.登录CentOS，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x atlassian-confluence-5.4.4-x64_1.bin</span><br><span class="line">./atlassian-confluence-5.4.4-x64_1.bin</span><br></pre></td></tr></table></figure><p>执行bin文件后，会经历三个确认</p><p>第一个，是否确认安装。[o]</p><p>第二个，选择安装方式，默认、自定义、升级现有的。[1]</p><p>第三个，确认安装。[i]</p><p>注：此时，安装已完成，不应该出现任何错误</p><p>2.http访问</p><p>观察第一步安装信息，可知，confluence打开8090端口。</p><p>访问 <a href="http://your.centos.ip:8090" target="_blank" rel="noopener">http://your.centos.ip:8090</a> 记录此页面中的Server ID</p><p>3.停止wiki服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/confluence stop</span><br></pre></td></tr></table></figure></p><p>4.将atlassian-extras-2.4.jar拷贝到本机，准备进行破解注：我这里是mac，所以如果你是windows或linux，用你的办法将文件拷贝到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp user_name@your.centos.ip:/opt/atlassian/confluence/confluence/WEB-INF/lib/atlassian-extras-2.4.jar .</span><br></pre></td></tr></table></figure><p>5.解压下载的压缩包后，里面有confluence5.1-crack.zip，将其解压得到confluence5.1-crack文件夹</p><p>将从centos下载下来的atlassian-extras-2.4.jar覆盖confluence5.1-crack里的atlassian-extras-2.4.jar</p><p>进入confluence5.1-crack/iNVISIBLE</p><p>MAC对应keygen_MacOSX.sh(linux对应keygen.sh)</p><p>由于我chmod +x keygen_MacOSX.sh后执行./keygen_MacOSX.sh报错，所以我打开keygen_MacOSX.sh看到其核心代码即是执行confluence_keygen.jar。于是，我直接执行下面命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/System/Library/Frameworks/JavaVM.framework/Versions/1.6/Home/bin/java -jar confluence_keygen.jar</span><br></pre></td></tr></table></figure></p><p>此时，会弹出UI界面</p><p>填写相关信息(name别太短)，最重要的是serverId，填写第二步获取的ServerId。</p><p>点击”patch!”，选择第四步从centos下载下来的放在confluence5.1-crack里的atlassian-extras-2.4.jar</p><p>点击”.gen!”， key文本框里会生成相应信息</p><p>6.此时confluence5.1-crack里会有atlassian-extras-2.4.jar和atlassian-extras-2.4.bak</p><p>将atlassian-extras-2.4.jar拷贝到服务器的/opt/atlassian/confluence/confluence/WEB-INF/lib/位置，覆盖此处的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp atlassian-extras-2.4.jar user_name@your.centos.ip:/opt/atlassian/confluence/confluence/WEB-INF/lib/</span><br></pre></td></tr></table></figure></p><p>7.启动wiki</p><p>/etc/init.d/confluence start<br>8.将第五步生成的key，拷贝放在第二步页面的License Key位置</p><p>9.点击“production installation”</p><p>10.在centos服务器上,将mysql驱动包放到confluence里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mysql-connector-java-5.1.24/mysql-connector-java-5.1.24-bin.jar /opt/atlassian/confluence/confluence/WEB-INF/lib/</span><br></pre></td></tr></table></figure></p><p>11.重启服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/confluence restart</span><br></pre></td></tr></table></figure></p><p>12.在页面上，选择数据库“MySQL”，点击“ Externam Database”</p><p>13.登录mysql 创建数据库及账号</p><p>我是在centos上有安装好的mysql</p><p>注：5.4.4版本的confluence，貌似对mysql的存储引擎有要求，需要是InnoDB(我第一次没有改，用的MyISAM，下一步就出错了)。</p><p> show variables like ‘%storage_engine%’;//查看默认存储引擎<br>如果是MyISAM的话，在/etc/my.cnf文件[mysqld]下添加default-storage-engine=InnoDB，重启mysql<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/mysqld restart</span><br><span class="line">mysql -uroot -p</span><br><span class="line">create database wiki character set UTF8;</span><br><span class="line">grant all on wiki.* to wiki_user@&quot;%&quot; identified by &quot;wiki_password&quot;;</span><br></pre></td></tr></table></figure></p><p>14.在页面上点击“Direct JDBC”</p><p>15.填写db信息</p><p>Driver Class Name不用变</p><p>Database URL，修正对应ip、port、database，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://localhost:3306/wiki?useUnicode=true&amp;characterEncoding=UTF8&amp;sessionVariables=storage_engine%3DInnoDB</span><br></pre></td></tr></table></figure></p><p>上面的连接符是”&amp;”不是”&amp;”，这样是没有问题的，如果你要用”&amp;”也可以尝试，但后面可能出错</p><p>User Name和Password填写第13步创建的用户名密码即可</p><p>16.点击“Next”，此时可能会有一个比较长的等待，如果此处出错了，停掉wiki服务，卸载wiki，删掉wiki文件，卸载数据库，从第一步重新来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/confluence stop</span><br><span class="line">/opt/atlassian/confluence/uninstall</span><br><span class="line">rm -rf /opt/atlassian</span><br><span class="line">rm -rf /var/atlassian</span><br><span class="line">drop database wiki //登录数据库</span><br></pre></td></tr></table></figure></p><p>此处可能出错的原因：</p><p>第2步使用域名，没用ip:port</p><p>第13步没设置默认存储引擎为InnoDB</p><p>第15步，ip、port、db或连接符不正确</p><p>当出现错误后，不要试图点击后退，修改信息，再尝试点击“Next”。直接按本步所说的做相关卸载操作，并修正产生问题的地方，从第一步开始。</p><p>17.如果上一步成功的话，点击“Empty Site”。你也可以点击“Example Site”。</p><p>18.点击“Manage users and groups within Confluence”，设置管理员相关信息。这里是“下一步”还是“确定”忘了，点击即可</p><p>19.点击further configuration</p><p>20.登录wiki，点击右上角齿轮图标下拉菜单最后一个菜单（插件），点击“upload add-on”，选择解压文件夹里的“Confluence-Language-STD-CN.jar”</p><p>21.很重要</p><p>vim /var/atlassian/application-data/confluence/confluence.cfg.xml<br>编辑此配置文件中“hibernate.connection.url”，注意连接符“&amp;”此处可能变为了“&amp;amp;”，要修改为“&amp;”修改完后重启wiki<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/confluence restart</span><br></pre></td></tr></table></figure></p><p>如果不进行此步骤，创建一些中文的内容，重启wiki，会让所有中文乱码，数据库里的数据都是乱码。</p><p>21.设置base url，job，创建空间，空间权限，用户等</p><p>22.添加一些中文内容后，重启wiki，再访问页面，看是否乱码，如果不乱码基本就没问题了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;团队还在刀耕火种，各种word文档满天飞，实在不能忍，于是在测试服务器上折腾了一个confluence方便团队协作。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>.gitignore文件设置忽略不生效的问题</title>
    <link href="https://github.com/DJoeyZhang/archives/88b92f76.html"/>
    <id>https://github.com/DJoeyZhang/archives/88b92f76.html</id>
    <published>2020-11-12T00:58:59.000Z</published>
    <updated>2020-11-12T01:01:19.497Z</updated>
    
    <content type="html"><![CDATA[<p>Git忽略规则(.gitignore配置）不生效原因和解决<br><a id="more"></a></p><p>第一种方法:</p><p>.gitignore中已经标明忽略的文件目录下的文件，git push的时候还会出现在push的目录中，或者用git status查看状态，想要忽略的文件还是显示被追踪状态。<br><br>原因是因为在git忽略目录中，新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，<br><br>这时候我们就应该先把本地缓存删除，然后再进行git的提交，这样就不会出现忽略的文件了。</p><p>解决方法: git清除本地缓存（改变成未track状态），然后再提交:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@kevin ~]# git rm -r --cached .</span><br><span class="line">[root@kevin ~]# git add .</span><br><span class="line">[root@kevin ~]# git commit -m &apos;update .gitignore&apos;</span><br><span class="line">[root@kevin ~]# git push -u origin master</span><br></pre></td></tr></table></figure></p><p>需要特别注意的是：<br><br>1）.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。<br><br>2）想要.gitignore起作用，必须要在这些文件不在暂存区中才可以，.gitignore文件只是忽略没有被staged(cached)文件，对于已经被staged文件，加入ignore文件时一定要先从staged移除，才可以忽略。</p><p>第二种方法:（推荐）<br><br>在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@kevin ~]# git update-index --assume-unchanged PATH                  //在PATH处输入要忽略的文件</span><br></pre></td></tr></table></figure></p><p>在使用.gitignore文件后如何删除远程仓库中以前上传的此类文件而保留本地文件<br><br>在使用git和github的时候，之前没有写.gitignore文件，就上传了一些没有必要的文件，在添加了.gitignore文件后，就想删除远程仓库中的文件却想保存本地的文件。这时候不可以直接使用”git rm directory”，这样会删除本地仓库的文件。可以使用”git rm -r –cached directory”来删除缓冲，然后进行”commit”和”push”，这样会发现远程仓库中的不必要文件就被删除了，以后可以直接使用”git add -A”来添加修改的内容，上传的文件就会受到.gitignore文件的内容约束。</p><p>额外说明：git库所在的文件夹中的文件大致有4种状态</p><p>Untracked:</p><p>未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</p><p>Unmodify:<br><br>文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改,<br><br>而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</p><p>Modified:<br><br>文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态,<br><br>使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改</p><p>Staged:<br><br>暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态.<br><br>执行git reset HEAD filename取消暂存, 文件状态为Modified</p><p>Git 状态 untracked 和 not staged的区别<br><br>1）untrack     表示是新文件，没有被add过，是为跟踪的意思。<br><br>2）not staged  表示add过的文件，即跟踪文件，再次修改没有add，就是没有暂存的意思</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git忽略规则(.gitignore配置）不生效原因和解决&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter 调试IOS真机遇到的问题</title>
    <link href="https://github.com/DJoeyZhang/archives/655c1a94.html"/>
    <id>https://github.com/DJoeyZhang/archives/655c1a94.html</id>
    <published>2020-11-10T01:47:05.000Z</published>
    <updated>2020-11-12T00:56:42.949Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些真机调试flutter遇到的坑。<br><a id="more"></a><br>1、遇到一个签名错误，开始以为是非开发者账号的问题，但是新建了一个原生demo还是报错，各种Google，说什么key chain,build settings,没有一个能解决。</p><hr><p>CodeSign /Volumes/HDD/OpenFrameworks/of_v0.9.8_osx_release/apps/plus-pool-light/pplight-ofx-098/bin/pplight-ofx-098Debug.app (in target ‘pplight-ofx-098’ from project ‘pplight-ofx-098’)<br>cd /Volumes/HDD/OpenFrameworks/of_v0.9.8_osx_release/apps/plus-pool-light/pplight-ofx-098<br>export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate</p><p>Signing Identity:     “-“</p><p> /usr/bin/codesign –force –sign - –entitlements /Volumes/HDD/OpenFrameworks/of_v0.9.8_osx_release/apps/plus-pool-light/pplight-ofx-098/build/pplight-ofx-098.build/Debug/pplight-ofx-098.build/pplight-ofx-098Debug.app.xcent –timestamp=none /Volumes/HDD/OpenFrameworks/of_v0.9.8_osx_release/apps/plus-pool-light/pplight-ofx-098/bin/pplight-ofx-098Debug.app</p><p>/Volumes/HDD/OpenFrameworks/of_v0.9.8_osx_release/apps/plus-pool-light/pplight-ofx-098/bin/pplight-ofx-098Debug.app: code object is not signed at all<br>In subcomponent: /Volumes/HDD/OpenFrameworks/of_v0.9.8_osx_release/apps/plus-pool-light/pplight-ofx-098/bin/pplight-ofx-098Debug.app/Contents/Frameworks/GLUT.framework<br>Command CodeSign failed with a nonzero exit code</p><hr><p>苦了四天，最后找到了解决方案：<br>I fixed this by adding –deep to Other Code Signing Flags in the Build Settings &gt; Signing</p><p>系统版本：10.15.7 MacOs catalina<br>Xcode版本：Version 12.1</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些真机调试flutter遇到的坑。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用Linux 速查</title>
    <link href="https://github.com/DJoeyZhang/archives/107df62c.html"/>
    <id>https://github.com/DJoeyZhang/archives/107df62c.html</id>
    <published>2020-11-09T08:41:14.000Z</published>
    <updated>2020-11-12T00:58:23.246Z</updated>
    
    <content type="html"><![CDATA[<p>命令总记不住，常用的收藏一下。<br><a id="more"></a><br>1、后台启动springboot jar包<br>nohup java -jar 自己的springboot项目.jar &gt;日志文件名.log 2&gt;&amp;1 &amp;<br>2、查看所有端口状态<br>ps aux</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;命令总记不住，常用的收藏一下。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web端录音拍照及音视频解决方案调研报告</title>
    <link href="https://github.com/DJoeyZhang/archives/6b6c3a59.html"/>
    <id>https://github.com/DJoeyZhang/archives/6b6c3a59.html</id>
    <published>2020-10-28T00:59:34.000Z</published>
    <updated>2020-11-11T02:54:17.778Z</updated>
    
    <content type="html"><![CDATA[<p>前端拍照、录音、播放功能去Flash依赖化实现调研。(详细方案内容在做脱敏处理)<br><a id="more"></a></p><h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h5><p>目前前端主流的四大浏览器内核：Trident（也称IE内核）、Chromium、Blink、Gecko。</p><p>因为主流移动端系统IOS、Android浏览器内核基于Chromium/webkit，并且移动端的跨端hybrid开发方案层出不穷，所以Chromium内核应用最广，连新版的Microsoft Edge也是基于Chromium内核设计,故Chromium内核有一统江湖的趋势。</p><h5 id="调研背景："><a href="#调研背景：" class="headerlink" title="调研背景："></a>调研背景：</h5><p>目前公司的部分前端项目的录音、播放、拍照等功能依赖Flash框架。而Chrome表示，由于Adobe公司将于2020年底停止对Flash的更新，故新版的Chrome浏览器也将停止对Flash的支持。</p><p>基于以上原因，前端工程的去Flash化应未雨绸缪。</p><p>考虑到目前移动端很多业务采用hybrid方案（H5页面适配移动端，一套脚本三端运行。例如:频繁更新的运营推广页，手机M站等）。</p><p>故，前端工程的去Flash依赖动作应兼容移动端的hybrid技术方案。</p><p>基于以上，设立本次调研方向：<br>1、基于Vue构建的SPA应用拍照录音、音视频方案。<br>2、移动端开发中的hybrid解决方案。</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><p>一、基于Vue构建的SPA应用拍照录音、音视频方案：</p><p>二、移动web hybrid跨端解决方案：</p><h5 id="尾语："><a href="#尾语：" class="headerlink" title="尾语："></a>尾语：</h5><p>近年来，随着移动web应用native -&gt; hybrid -&gt; cross-platform的架构演进，跨端技术如React Native、Flutter异军突起。大前端技术主要想解决的问题其实就是如Java那样“write once,run anywhere”，为此Google还推出了Flutter For Web技术以期三端一统。<br>其中移动端利用webview 进行h5混合开发的技术手段虽在渲染效率和用户体验上照比跨端技术差。但在运营页，活动页等频繁更新的业务板块依然占有一席之地。所以前端工程应注意在移动设备上的兼容性。<br>以上为我“关于Web端拍照、录音以及音视频解决方案”的调研报告。<br>时间仓促，如有不足，敬请斧正。</p><h5 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h5><p>1、<a href="https://plainnany.github.io/2017/06/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">https://plainnany.github.io/2017/06/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E7%AE%80%E4%BB%8B/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端拍照、录音、播放功能去Flash依赖化实现调研。(详细方案内容在做脱敏处理)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库相关记录</title>
    <link href="https://github.com/DJoeyZhang/archives/76c48a64.html"/>
    <id>https://github.com/DJoeyZhang/archives/76c48a64.html</id>
    <published>2020-10-12T07:57:11.000Z</published>
    <updated>2020-10-14T02:00:28.165Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些数据库相关<br><a id="more"></a></p><p>1、使用sequel pro操作数据库<br><br><a href="https://blog.csdn.net/zs_pnzzz/article/details/79769146" target="_blank" rel="noopener">https://blog.csdn.net/zs_pnzzz/article/details/79769146</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些数据库相关&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>apktool command</title>
    <link href="https://github.com/DJoeyZhang/archives/bb48e990.html"/>
    <id>https://github.com/DJoeyZhang/archives/bb48e990.html</id>
    <published>2020-10-10T08:52:59.000Z</published>
    <updated>2020-10-10T08:54:21.759Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些apktool使用<br><a id="more"></a></p><p>1、apktool d my.apk 无权限时：chmod a+x *.sh<br><br>2、dex2jar后用JD_GUI打开报路径错误时：sudo chmod +xr</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些apktool使用&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一些前端面试题</title>
    <link href="https://github.com/DJoeyZhang/archives/706e1d98.html"/>
    <id>https://github.com/DJoeyZhang/archives/706e1d98.html</id>
    <published>2020-09-14T07:55:10.000Z</published>
    <updated>2020-10-19T07:15:04.602Z</updated>
    
    <content type="html"><![CDATA[<p>preface：<br><br>应朋友邀请，去新公司做前端负责人。公司目前前端工作内容主要是后台管理界面。一些老的项目是vue开发维护的。技术栈主要在vue-admin和react-admin。<br><br>记录整理的一些面试题，着重考察候选人前端基础和框架的熟悉程度，提升考察候选人对框架的理解和一些发散思维。<br><a id="more"></a></p><h5 id="考察范围："><a href="#考察范围：" class="headerlink" title="考察范围："></a>考察范围：<br></h5><h6 id="一、JS基础考察："><a href="#一、JS基础考察：" class="headerlink" title="一、JS基础考察："></a>一、JS基础考察：<br></h6><p>1、闭包和作用域,箭头函数中的this。<br><br>2、深浅拷贝的区别。<br><br>3、http\https\websocket区别和使用场景，常用的请求方法及状态码。<br><br>4、浏览器缓存。强缓存和协商缓存区别。<br></p><h6 id="二、Vue基础考察"><a href="#二、Vue基础考察" class="headerlink" title="二、Vue基础考察:"></a>二、Vue基础考察:<br></h6><p>1、组件生命周期？哪个钩子函数中可以拿到Dom节点, 在created还是mounted？<br><br>2、父子组件通信，事件和属性的传递模式。<br><br>3、MVC \ MVVM 的理解？Vue借鉴了哪种模式？双向绑定的数据，变量污染如何排查。<br><br>4、数据驱动父组件重绘时，部分子组件不想重绘，如何做? (keep=alive) <br></p><h6 id="三、React基础考察"><a href="#三、React基础考察" class="headerlink" title="三、React基础考察:"></a>三、React基础考察:<br></h6><p>1、组件key的作用。<br><br>2、lodash 防抖和节流。<br><br>3、组件生命周期，网络请求通常写在哪个钩子上？虚拟DOM 的diff算法处理，shouldupdate回调时机，顺便问问渲染性能优化。<br><br>5、vuex和Redux的设计和作用。<br></p><h6 id="四、针对简历项目提问考察"><a href="#四、针对简历项目提问考察" class="headerlink" title="四、针对简历项目提问考察"></a>四、针对简历项目提问考察<br></h6><h6 id="五、发散思维考察："><a href="#五、发散思维考察：" class="headerlink" title="五、发散思维考察："></a>五、发散思维考察：<br></h6><p>1、JQ和vue\react比较，JQ有哪些缺陷。<br><br>2、从浏览器地址栏输入url到页面加载渲染出来，都发生了什么。<br><br>3、Vue工程，调试run serve没有问题，但是build后的dist在跑在部分浏览器有问题，并且控制台输出信息有限（SCRIPT1002），如何排查？<br>5、大数据可视化方面：D3.js和echarts比较。<br>6、职业规划。期望薪资。<br></p><h5 id="六、评价维度："><a href="#六、评价维度：" class="headerlink" title="六、评价维度："></a>六、评价维度：<br></h5><p>1、基础知识<br><br>2、框架熟悉度<br><br>3、语言表达、协作沟通能力<br><br>4、可塑性（学习意愿）<br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;preface：&lt;br&gt;&lt;br&gt;应朋友邀请，去新公司做前端负责人。公司目前前端工作内容主要是后台管理界面。一些老的项目是vue开发维护的。技术栈主要在vue-admin和react-admin。&lt;br&gt;&lt;br&gt;记录整理的一些面试题，着重考察候选人前端基础和框架的熟悉程度，提升考察候选人对框架的理解和一些发散思维。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>来话应用Flutter重构可研</title>
    <link href="https://github.com/DJoeyZhang/archives/61fe53de.html"/>
    <id>https://github.com/DJoeyZhang/archives/61fe53de.html</id>
    <published>2020-08-31T01:00:27.000Z</published>
    <updated>2020-08-31T05:37:06.341Z</updated>
    
    <content type="html"><![CDATA[<p>目标和资源：<br><br>    来话应用一期Android端上线后，希望以flutter重构业务逻辑，实现ADR/IOS双端上线。 <br><br>   目前组内可供开发人力，Android 3人，IOS/MACOS 2人。<br><a id="more"></a></p><h5 id="一、工作拆解："><a href="#一、工作拆解：" class="headerlink" title="一、工作拆解："></a>一、工作拆解：</h5><h6 id="1、架构设计："><a href="#1、架构设计：" class="headerlink" title="1、架构设计："></a>1、架构设计：</h6><p>来话Android端架构设计：<br><br>模块化解耦合，抽取module_base,module_function,module_user,app四个模块，其中module_base承载应用的基类和MVVM框架设计，module_function和module_user承载产品的具体功能函数和用户的信息管理，app模块是整个应用的壳工程，用来对接一些三方SDK。工程采用了jetbrain anko,okhttp3/retrofit/rxjava/dagger2/glide等一系列流行框架作为脚手架。<br></p><p>来话Flutter端架构设计：<br><br>总体设计上可复用来话Android端架构。工具框架参考flutter开发者社区，大体覆盖了我方功能需求。但flutter所选框架在Adr/IOs双端的兼容性需要双端工程师进行调试。</p><h6 id="2、Tencent-IM-SDK-SensorSDK-TingYun-SDK-XGPush的桥接（工作量大，重难点）"><a href="#2、Tencent-IM-SDK-SensorSDK-TingYun-SDK-XGPush的桥接（工作量大，重难点）" class="headerlink" title="2、Tencent IM SDK / SensorSDK / TingYun SDK / XGPush的桥接（工作量大，重难点）"></a>2、Tencent IM SDK / SensorSDK / TingYun SDK / XGPush的桥接（工作量大，重难点）</h6><p>以上四者SDK，分别提供了来话的 即时通话能力 、 商化统计能力 、 性能监控能力 、推送及接收消息能力。且此四者SDK并无Flutter版本，需要双端工程师根据SDK的开放API，选定合适版本进行桥接编写。</p><h6 id="3、工具类封装、基类编写："><a href="#3、工具类封装、基类编写：" class="headerlink" title="3、工具类封装、基类编写："></a>3、工具类封装、基类编写：</h6><p>此工作采用Dart,由Adr工程师编写，IOS端工程师负责单侧调试。</p><h6 id="4、功能页面的编写：（工作量大-且琐碎）"><a href="#4、功能页面的编写：（工作量大-且琐碎）" class="headerlink" title="4、功能页面的编写：（工作量大,且琐碎）"></a>4、功能页面的编写：（工作量大,且琐碎）</h6><p>此工作采用Dart,由Adr工程师编写，IOS端工程师负责单侧调试。</p><h6 id="5、权限功能编写："><a href="#5、权限功能编写：" class="headerlink" title="5、权限功能编写："></a>5、权限功能编写：</h6><p>来话产品所需求（eg:静默下载，本地通讯录联系人等）的一系列敏感权限，IOS工程师需评估其对于上架审核有无影响。部分诸如强制更新，后台唤起等功能IOS端恐怕实现困难，需寻找替代方案。</p><h5 id="二、风险评估："><a href="#二、风险评估：" class="headerlink" title="二、风险评估："></a>二、风险评估：</h5><h6 id="1、-开发人员技术栈现状："><a href="#1、-开发人员技术栈现状：" class="headerlink" title="1、 开发人员技术栈现状："></a>1、 开发人员技术栈现状：</h6><p>有flutter开发经验的Android工程师仅1人。其余四人需要培训学习后兼顾进行开发，人力投入上难以 all in。</p><h6 id="2、-应用权限申请："><a href="#2、-应用权限申请：" class="headerlink" title="2、 应用权限申请："></a>2、 应用权限申请：</h6><p>来话Android端申请了许多诸如：通讯录读取、静默下载、浮动在上层应用等敏感权限。IOS端恐怕无法申请并过审。</p><h5 id="三、开发、协作模式："><a href="#三、开发、协作模式：" class="headerlink" title="三、开发、协作模式："></a>三、开发、协作模式：</h5><p>人力现状：<br>Android工程师充足，但手中有其他工作；IOS工程师人力少，手中有其他工作且处于异地。</p><h6 id="建议的协作开发模式："><a href="#建议的协作开发模式：" class="headerlink" title="建议的协作开发模式："></a>建议的协作开发模式：</h6><p>1、Android端先行进入调研开发。工作优先级：SDK的桥接封装协议制定及编码 &gt; 框架设计、基类、工具编写 &gt; 具体功能界面编写实现。</p><p>2、IOS端待SDK封装协议制定后进入开发。根据Android端开发进度进行适配(android端需制定短期里程碑计划，定期输出flutter编码供IOS端适配调试)。</p><h5 id="四、工期评估："><a href="#四、工期评估：" class="headerlink" title="四、工期评估："></a>四、工期评估：</h5><h6 id="1、SDK封装协议及编码开发：-—-共计：30人日"><a href="#1、SDK封装协议及编码开发：-—-共计：30人日" class="headerlink" title="1、SDK封装协议及编码开发： —-共计：30人日"></a>1、SDK封装协议及编码开发： —-共计：30人日</h6><pre><code>Tencent IM SDK 桥接协议制定编写。----7人日SensorSDK 桥接协议制定编写。----7人日TingYun SDK 桥接协议制定编写。----7人日XGPush SDK 桥接协议制定编写。----7人日调试自测。 ----2人日</code></pre><h6 id="2、架构设计、框架开发：-—-共计：6人日"><a href="#2、架构设计、框架开发：-—-共计：6人日" class="headerlink" title="2、架构设计、框架开发： —-共计：6人日"></a>2、架构设计、框架开发： —-共计：6人日</h6><pre><code>工程架构搭建。----2人日依赖管理。----2人日调试自测。 ----2人日</code></pre><h6 id="3、功能页面编写：-—-共计：45人日"><a href="#3、功能页面编写：-—-共计：45人日" class="headerlink" title="3、功能页面编写： —- 共计：45人日"></a>3、功能页面编写： —- 共计：45人日</h6><pre><code>首页通话记录模块。----2人日首页通讯录模块。 ----2人日首页设置模块。----1人日消息模块。----2人日预约功能模块。 ---- 3人日多选联系人功能模块。 ----3人日设置模块、关于模块、扫一扫添加联系人模块。----3人日添加联系人、通讯录校验、好友邀请模块。----4人日下载升级功能。 ----3人日单人、多人通话功能。 ----14人日登陆注册模块。----2人日所有模块埋点统计。----2人日调试自测。 ----4人日</code></pre><h6 id="4、基类、工具类编写：-—-共计：5人日"><a href="#4、基类、工具类编写：-—-共计：5人日" class="headerlink" title="4、基类、工具类编写： —-共计：5人日"></a>4、基类、工具类编写： —-共计：5人日</h6><h6 id="5、权限体系编写：-—-6人日"><a href="#5、权限体系编写：-—-6人日" class="headerlink" title="5、权限体系编写： —-6人日"></a>5、权限体系编写： —-6人日</h6><p>共计：92人日。（预估前提：在重构工作无产品干预的前提下，仅以我个人开发能力all in状态进行Android端flutter重构的乐观评估。IOS侧适配工期需IOS工程师另行评估）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目标和资源：&lt;br&gt;&lt;br&gt;    来话应用一期Android端上线后，希望以flutter重构业务逻辑，实现ADR/IOS双端上线。 &lt;br&gt;&lt;br&gt;   目前组内可供开发人力，Android 3人，IOS/MACOS 2人。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记录一些好用的配置工具和lint配置</title>
    <link href="https://github.com/DJoeyZhang/archives/70f14e75.html"/>
    <id>https://github.com/DJoeyZhang/archives/70f14e75.html</id>
    <published>2020-08-28T00:56:54.000Z</published>
    <updated>2020-08-28T00:58:15.200Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器。<br><a id="more"></a></p><p>1、 cc 开发eslint 配置<br><br><a href="https://www.dazhuanlan.com/2020/01/06/5e12ae47f1581/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2020/01/06/5e12ae47f1581/</a></p><p>2、MacBook brew update 慢的问题。<br><a href="https://www.jianshu.com/p/edfe9af41117" target="_blank" rel="noopener">https://www.jianshu.com/p/edfe9af41117</a></p><p>3、在mac终端先cd对应目录，然后执行以下命令，目录下会多了一些jpg格式的图片。<br>for i in .CR2; do sips -s format jpeg $i –out “${i%.}.jpg”; done</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工欲善其事，必先利其器。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一起来找茬开发手记。cocos creator探索之路</title>
    <link href="https://github.com/DJoeyZhang/archives/8434bd43.html"/>
    <id>https://github.com/DJoeyZhang/archives/8434bd43.html</id>
    <published>2020-08-20T16:10:53.000Z</published>
    <updated>2020-08-25T02:19:58.835Z</updated>
    
    <content type="html"><![CDATA[<p>要睡了,先随便记点，有空再整理。<br><a id="more"></a></p><p>0、关于上次讨论热区配置问题：解决方案如上图<br>    设图片width，height均为1.<br>    左上角建立坐标系，x1,x2,y1,y2分别为x轴坐标/width，y轴坐标/height的比例值。<br>    x1,x2,y1,y2 in (0,1)</p><pre><code>给出配置文件数据结构形如：{url:&quot;www.picture.com&quot;,hotArea:[    {x1:0.5,x2:0.75,y1:0.25,y2:0.5},    ...]如此运营每次设置好热区后，只需要计算一下这四个数就可以了，比切九宫格简单。配置像素值不可取，因图片在前端展示可能会压缩，且按照dip、pt或者rem适配，在不同设备上，px值应该不一样。</code></pre><p>}</p><p>1、关于前端技术选型：</p><pre><code>抖音小游戏支持的主流2种引擎：Cocos Creator,Egret白鹭其中egret引擎文档已经上次更新已经是16年。抛弃。经技术社区调研，CC具备以下优点：version 2.4.2 support了字节小游戏以及字节小游戏开放域的构建发布。引擎侵入性很小，可在字节开发者工具中进行产物二次开发。ES6/7语法，JS栈亲和。API覆盖全面，文档详细。综上，前端决定选用CC引擎。</code></pre><p>2、关于游戏服务端调研：</p><pre><code>浏览多个技术社区和逼乎专栏，多数推荐网易LeanCloud作为游戏服务的后端支持。LeanCloud提供了详细的多人在线游戏server解决方案。部署和运维看起来也挺方便的。收费看着也还行，官网丢出来供服务端大佬参考：https://leancloud.cn/docs/multiplayer-server.html#hash1086233181</code></pre><p>3、Cocos Creator .gitIgnore config<br><a href="https://blog.csdn.net/themagickeyjianan/article/details/82901189" target="_blank" rel="noopener">https://blog.csdn.net/themagickeyjianan/article/details/82901189</a></p><p>4、坑。8月23日进开发，因产品设计较多的路由页面，突发奇想用小程序模版开发。结果25日发现小程序中调用不到小游戏的API，并且发布也归类不到小游戏，唉，重头再来吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要睡了,先随便记点，有空再整理。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin开发编码规范</title>
    <link href="https://github.com/DJoeyZhang/archives/10213c17.html"/>
    <id>https://github.com/DJoeyZhang/archives/10213c17.html</id>
    <published>2020-07-28T02:00:04.000Z</published>
    <updated>2020-07-28T03:41:49.657Z</updated>
    
    <content type="html"><![CDATA[<p></p><h4>Preface:</h4><br>众所周知，Android团队已经接纳Kotlin为其平台性开发语言，可以预见将来会有越来越多的Android项目用Kotlin写成。随着Kotlin被引入到不同的开发团队，与其相关的代码规范也会越来越受关注。<br><a id="more"></a><br>以下是我查找多方资料初步整理的kotlin编码规范，如有不妥，敬请斧正。<p></p><p></p><h5>命名格式</h5><br>总体来说，Kotlin命名格式要和Java命名规范保持一致，因为Kotlin也是JVM兼容的语言。<p></p><p></p><h5>包名</h5><br>包的命名规则和Java一样：全小写，当遇到多个词连接的场景，不要使用下划线(_)和连字号(-)。<p></p><p><b>推荐</b><br><br>package vn.asiantech.android<br><br><b>不推荐</b><br><br>package Vn.Asiantech.Android</p><p></p><h5>类和接口</h5><br>命名遵守大驼峰规则（首字母大写）。<p></p><p><b>推荐</b><br><br>HomeActivity<br><br>MainFragment<br></p><p></p><h5>方法</h5><br>命名遵守小驼峰规则（首字母小写）。<p></p><p><b>推荐</b><br><br>setData<br><br>getApiNews</p><p></p><h5>字段（Fields）</h5><br>总体来说，字段命名遵守小驼峰规则，不建议使用匈牙利法。<p></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  var publicField: Int = 0</span><br><span class="line">  val person = Person()</span><br><span class="line">  private var privateField: Int?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而伴生对象中的常量定义要遵守规则：全大写，单词连接使用下划线。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">companion object &#123;</span><br><span class="line">  const val THE_ANSWER = 42</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="变量和参数"><a href="#变量和参数" class="headerlink" title="变量和参数"></a>变量和参数</h5><p>一句话概括： 小驼峰命名法。<br><br>不建议使用单个字符的变量，除非是循环中的临时变量。</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>首字母缩略词作为完整单词看待，适时选择命名规则。</p><p><b>推荐</b><br><br>XMLHTTPRequest<br><br>URL: String? <br><br>findPostByID<br><br><b>不推荐</b><br><br>XmlHttpRequest<br><br>url: String<br><br>findPostById<br></p><h5 id="间距"><a href="#间距" class="headerlink" title="间距"></a>间距</h5><p><b>缩进</b><br><br>缩进使用4个空格，不建议使用tabs - 制表符。</p><p><b>闭包</b><br><br>闭包的缩进使用2个空格，</p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i in 0..9) &#123;</span><br><span class="line">  Log.i(TAG, &quot;index=&quot; + i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i in 0..9) &#123;</span><br><span class="line">    Log.i(TAG, &quot;index=&quot; + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h5><p>新的换行缩进使用4个空格，而不是默认的8个。</p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val widget: CoolUiWidget =</span><br><span class="line">    someIncrediblyLongExpression(that, reallyWouldNotFit, on, aSingle, line)</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val widget: CoolUiWidget =</span><br><span class="line">        someIncrediblyLongExpression(that, reallyWouldNotFit, on, aSingle, line)</span><br></pre></td></tr></table></figure></p><h5 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h5><p>每行不应超过130个字符，这在Android Studio内可以配置。<br><br>如果单行代码超过限制需要换行显示，使用, / : / { , = 作为首行的结尾。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun setData(name: String, age: Int, class: String, date: String, message: String,</span><br><span class="line">     time: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun getInfo(name: String, birth: String, age: Int, weight: Float, hight: Float) =</span><br><span class="line">   getInfo().apply &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data class Animal(private val weight: Float, private val hight: Float) :</span><br><span class="line">         AbstractAnimal() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="垂直间距"><a href="#垂直间距" class="headerlink" title="垂直间距"></a>垂直间距</h5><p>方法体之间保留一个空行，这样可以让结构清晰。<br><br>方法体内的空行用来分割不同功能，这样如果一个方法内分多个部分，也许需要重构代码了。<br></p><h5 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h5><p>类型和父类型之间的冒号前面要保留空格，而变量和类型之间的冒号前没有空格。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Foo&lt;out T : Any&gt; : Bar &#123;</span><br><span class="line">    fun foo(a: Int): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 申明变量类型</span><br><span class="line"></span><br><span class="line">val firstName: String</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Foo&lt;out T:Any&gt;: Bar &#123;</span><br><span class="line">    fun foo(a : Int):T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 申明变量类型</span><br><span class="line"></span><br><span class="line">val firstName:String</span><br></pre></td></tr></table></figure></p><h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><p>在定义类的时候，在结构体的右括号和类主题的左括号之间保留空格，结构体的每个参数单行显示。<br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User(</span><br><span class="line">    public open var firstName: String,</span><br><span class="line">    public open var lastName: String</span><br><span class="line">) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class User(public open var firstName: String, public open var lastName: String)&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>在定义子类或实现接口的时候，上面提到的规则仍然适用，且冒号和父类名之间要保留空格，冒号和结构体之间不需要空格。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User(</span><br><span class="line">    public open var firstName: String,</span><br><span class="line">    public open var lastName: String</span><br><span class="line">): RealmObject() &#123;&#125;</span><br></pre></td></tr></table></figure></p><h5 id="分号（-）"><a href="#分号（-）" class="headerlink" title="分号（;）"></a>分号（;）</h5><p>在Kotlin中避免使用分号。</p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val horseGiftedByTrojans = true</span><br><span class="line">if (horseGiftedByTrojans) &#123;</span><br><span class="line">  bringHorseIntoWalledCity()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val horseGiftedByTrojans = true;</span><br><span class="line">if (horseGiftedByTrojans) &#123;</span><br><span class="line">  bringHorseIntoWalledCity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="括号格式"><a href="#括号格式" class="headerlink" title="括号格式"></a>括号格式</h5><p>方法体的大括号和其他大括号首括号和前面代码在同一行，尾括号新起一行。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  fun doSomething() &#123;</span><br><span class="line">    if (someTest) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">&#123;</span><br><span class="line">  fun doSomething()</span><br><span class="line">  &#123;</span><br><span class="line">    if (someTest)</span><br><span class="line">    &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="括号格式-1"><a href="#括号格式-1" class="headerlink" title="括号格式"></a>括号格式</h5><p>条件判断语句必须内嵌在括号里，无论其是多少行。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (someTest) &#123;</span><br><span class="line">  doSomething()</span><br><span class="line">&#125;</span><br><span class="line">if (someTest) &#123; doSomethingElse() &#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (someTest)</span><br><span class="line">  doSomething()</span><br><span class="line">if (someTest) doSomethingElse()</span><br></pre></td></tr></table></figure></p><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>尽可能使用Kotlin原生类型。</p><h5 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h5><p>避免显式地声明Unit类型，因为不显式声明返回类型的函数都会返回 Unit 类型。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun doSomething()</span><br></pre></td></tr></table></figure></p><p>不推荐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun doSomething(): Unit</span><br></pre></td></tr></table></figure></p><h5 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h5><p>优先使用类型推导。（对编译速度有少许影响？）<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val something = MyType()</span><br><span class="line">val meaningOfLife = 42</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val something: MyType = MyType()</span><br><span class="line">val meaningOfLife: Int = 42</span><br></pre></td></tr></table></figure></p><h5 id="常量-vs-变量"><a href="#常量-vs-变量" class="headerlink" title="常量 vs 变量"></a>常量 vs 变量</h5><p>定义常量时使用关键词val， 定义变量时使用关键词var。<br><br>建议： 把所有的值使用val定义，且只在编译器警告的时候修订为var。</p><h5 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h5><p>伴生对象应定义在类文件的上面，而关于伴生对象的命名规范要遵守Java标准规范。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MainFragment: Fragment() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        const val TYPE_VIEW_HEADER = 0</span><br><span class="line">        const val TYPE_VIEW_FOOTER = 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MainFragment: Fragment() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val TypeViewHeader = 0</span><br><span class="line">        val TypeViewFooter = 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>推荐使用字符串插值语法糖。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val fullName = &quot;$&#123;user.firstName&#125; $&#123;user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val fullName = user.firstName + &quot; &quot; + user.lastName</span><br></pre></td></tr></table></figure></p><h5 id="选配型（-）"><a href="#选配型（-）" class="headerlink" title="选配型（?）"></a>选配型（?）</h5><p>变量和方法返回可以声明为选配型，这种情况赋值null也是允许的。<br></p><p>使用隐式拆包!!时候要小心，只能在确认实例对象在被使用前已经初始化，如在Activity方法onCreate使用的子视图。<br></p><p>在为选配型变量和参数命名的时候，不用使用类maybeView 和 optionalString的名称，因为选配类型已经表明了这一点。<br></p><p>在访问选配型变量值时，可使用可选链（Optional Chaining）。<br></p><p><b>eg:editText?.setText(“foo”)</b></p><h5 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h5><p>使用IDE提示<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val array = ArrayList&lt;Int&gt;()</span><br><span class="line">array[0]</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">activity().finish()</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val array = ArrayList&lt;Int&gt;()</span><br><span class="line">array.get(0)</span><br><span class="line"></span><br><span class="line">// or</span><br><span class="line"></span><br><span class="line">getActivity().finish()</span><br></pre></td></tr></table></figure></p><p>it 在 Lambda 语句中适应较广范围。<br><br><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  it?.let &#123; animal -&gt; animal.foo() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; animal -&gt; </span><br><span class="line">  animal?.let &#123; it.foo() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用类型推断，除非是难以理解的时候。"><a href="#使用类型推断，除非是难以理解的时候。" class="headerlink" title="使用类型推断，除非是难以理解的时候。"></a>使用类型推断，除非是难以理解的时候。</h5><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//属性</span><br><span class="line">val age = 0       // Int</span><br><span class="line">val foo = 10L     // Long</span><br><span class="line">val height = 100f // Float</span><br><span class="line"></span><br><span class="line">//函数</span><br><span class="line">// return Boolean</span><br><span class="line">fun Context.isConnectToWifi() =</span><br><span class="line">      (getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager)</span><br><span class="line">         .activeNetworkInfo?.type == ConnectivityManager.TYPE_WIFI</span><br><span class="line"></span><br><span class="line">// return Point</span><br><span class="line">fun Display.getSize(): Point = Point().apply &#123; getSize(this) &#125;</span><br></pre></td></tr></table></figure></p><h5 id="不要显式地写for循环。"><a href="#不要显式地写for循环。" class="headerlink" title="不要显式地写for循环。"></a>不要显式地写for循环。</h5><p>Kotlin中集合的支持forEach遍历。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(0..9).forEach &#123;</span><br><span class="line">// todo somethings</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(0..9).forEachIndexed &#123; index, value -&gt;</span><br><span class="line">// todo somethings</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i in 0..9) &#123;</span><br><span class="line">  // todo somethings</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用-to-快速创建Pair类的实例。"><a href="#使用-to-快速创建Pair类的实例。" class="headerlink" title="使用 to 快速创建Pair类的实例。"></a>使用 to 快速创建Pair类的实例。</h5><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val pair = Pair(foo, bar)</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val pair = foo to bar</span><br></pre></td></tr></table></figure></p><h5 id="使用优雅的类型转换。"><a href="#使用优雅的类型转换。" class="headerlink" title="使用优雅的类型转换。"></a>使用优雅的类型转换。</h5><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dog as? Animal ?: throw IllegalArgumentException(&quot;not Animal!&quot;)</span><br><span class="line">dog.foo()</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (dog !is Animal) &#123;</span><br><span class="line">    throw IllegalArgumentException(&quot;not Animal!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">dog.foo()</span><br></pre></td></tr></table></figure></p><h5 id="Getters-amp-Setters"><a href="#Getters-amp-Setters" class="headerlink" title="Getters &amp; Setters"></a>Getters &amp; Setters</h5><p> Kotlin中推荐直接访问属性。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// syntax</span><br><span class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 自定义setter</span><br><span class="line">var stringRepresentation: String</span><br><span class="line">    get() = this.toString()</span><br><span class="line">    set(value) &#123;</span><br><span class="line">        setDataFromString(value) // parses the string and assigns values to other properties</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="When语句"><a href="#When语句" class="headerlink" title="When语句"></a>When语句</h5><p>Kotlin的When语句和Java中的Switch有稍许区别，如不会fall through。如果不同的case具有相同的处理策略，使用逗号（,）,并且else语句是必须的。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">when (anInput) &#123;</span><br><span class="line">  1, 2 -&gt; doSomethingForCaseOneOrTwo()</span><br><span class="line">  3 -&gt; doSomethingForCaseThree()</span><br><span class="line">  else -&gt; println(&quot;No case satisfied&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">when (anInput) &#123;</span><br><span class="line">  1 -&gt; doSomethingForCaseOne()</span><br><span class="line">  2 -&gt; doSomethingForCaseOneOrTwo()</span><br><span class="line">  3 -&gt; doSomethingForCaseThree()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="变量可视性修饰符"><a href="#变量可视性修饰符" class="headerlink" title="变量可视性修饰符"></a>变量可视性修饰符</h5><p>默认修饰符是public，如果没有其他需要可以省略。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val wideOpenProperty = 1</span><br><span class="line">private val myOwnPrivateProperty = &quot;private&quot;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public val wideOpenProperty = 1</span><br><span class="line">private val myOwnPrivateProperty = &quot;private&quot;</span><br></pre></td></tr></table></figure></p><h5 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h5><p>对于每个类，方法和成员变量，访问控制修饰符要显示定义清晰。<br></p><h5 id="变量和字段"><a href="#变量和字段" class="headerlink" title="变量和字段"></a>变量和字段</h5><p>单行一个声明。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username: String</span><br><span class="line">twitterHandle: String</span><br></pre></td></tr></table></figure></p><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>普遍来说，每一个文件定义一个类，对于适合的场合依然可以使用内部类。<br></p><h5 id="Data-类型对象"><a href="#Data-类型对象" class="headerlink" title="Data 类型对象"></a>Data 类型对象</h5><p>对于简单的数据结构，推荐使用data类。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class Person(val name: String)</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name: String) &#123;</span><br><span class="line">  override fun toString() : String &#123;</span><br><span class="line">    return &quot;Person(name=$name)&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>优先使用静态变量，避免使用枚举类，因为内存开销太大。<br><br>如果枚举类没有其他方法，不用换行。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private enum CompassDirection &#123; EAST, NORTH, WEST, SOUTH &#125;</span><br></pre></td></tr></table></figure></p><h5 id="注解（Annotations）"><a href="#注解（Annotations）" class="headerlink" title="注解（Annotations）"></a>注解（Annotations）</h5><p>使用Java式标准注解，特别是override， 关键字要和函数的声明保持同一行。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">  super.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">  super.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Annotations应该在类的上面，-内联如果注解类中的字段"><a href="#Annotations应该在类的上面，-内联如果注解类中的字段" class="headerlink" title="Annotations应该在类的上面， 内联如果注解类中的字段,"></a>Annotations应该在类的上面， 内联如果注解类中的字段,</h5><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Root(strict=false) </span><br><span class="line">public open class User (</span><br><span class="line">    @field:Element public open var firstName: String? = &quot;&quot;,</span><br><span class="line">    @field:Element public open var lastName: String? = &quot;&quot;,</span><br><span class="line">) &#123;...&#125;</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Root(strict=false) public open class User (</span><br><span class="line">    @field:Element </span><br><span class="line">    public open var firstName: String? = &quot;&quot;,</span><br><span class="line">    @field:Element </span><br><span class="line">    public open var lastName: String? = &quot;&quot;,</span><br><span class="line">) &#123;...&#125;</span><br></pre></td></tr></table></figure></p><h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><p>XML文件命名<br><br>文件名要以展示视图的类型作为前缀。<br></p><p><b>推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">activity_login.xml</span><br><span class="line">fragment_main_screen.xml</span><br><span class="line">button_rounded_edges.xml</span><br></pre></td></tr></table></figure></p><p><b>不推荐</b><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">login.xml</span><br><span class="line">main_screen.xml</span><br><span class="line">rounded_edges_button.xml</span><br></pre></td></tr></table></figure></p><h5 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h5><p>和Java一样， XML文件使用2个字符缩进。<br></p><p>使用上下文相关的XML<br><br>任何时候，XML都要定义在相关的文件内。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Strings =&gt; res/values/strings.xml</span><br><span class="line">Styles =&gt; res/values/styles.xml</span><br><span class="line">Colors =&gt; res/color/colors.xml</span><br><span class="line">Animations =&gt; res/anim/</span><br><span class="line">Drawable =&gt; res/drawable</span><br></pre></td></tr></table></figure><h4 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h4><p>我配置的一个Formatter Config,个人感觉比较好用，如有优化，欢迎PR:<br><br><a href="https://github.com/DJoeyZhang/FormatterSetting.gitt">Formatter传送门</a><br><br>参考资料：<br><br><a href="https://kotlinlang.org/docs/reference/properties.html" target="_blank" rel="noopener">kotlin官方文档</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;h4&gt;Preface:&lt;/h4&gt;&lt;br&gt;众所周知，Android团队已经接纳Kotlin为其平台性开发语言，可以预见将来会有越来越多的Android项目用Kotlin写成。随着Kotlin被引入到不同的开发团队，与其相关的代码规范也会越来越受关注。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Thread.sleep(0)</title>
    <link href="https://github.com/DJoeyZhang/archives/a239bad0.html"/>
    <id>https://github.com/DJoeyZhang/archives/a239bad0.html</id>
    <published>2020-06-10T01:42:03.000Z</published>
    <updated>2020-06-11T06:54:47.185Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我们可能经常会用到 Thread.Sleep 函数来吧使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？<br></p><h6 id="思考下面这两个问题："><a href="#思考下面这两个问题：" class="headerlink" title="思考下面这两个问题："></a>思考下面这两个问题：<br></h6><p>假设现在是 2020-05-24 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2020-05-24 12:00:01.000 的时候，这个线程会不会被唤醒？<br><br>某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。<br><br>既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？<br><br><a id="more"></a><br>我们先回顾一下操作系统原理<br><br>操作系统中，CPU竞争有很多种策略。<br>Unix系统使用的是时间片算法，而Windows则属于抢占式的。在时间片算法中，所有的进程排成一个队列。操作系统按照他们的顺序，给每个进程分配一段时间，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。<br><br>所谓抢占式操作系统，就是说如果一个进程得到了 CPU 时间，除非它自己放弃使用 CPU ，否则将完全霸占 CPU 。因此可以看出，在抢 占式操作系统中，操作系统假设所有的进程都是“人品很好”的，会主动退出 CPU 。<br><br>在抢占式操作系统中，假设有若干进程，操作系统会根据他们的优先级、饥饿时间（已经多长时间没有使用过 CPU 了），给他们算出一个总的优先级来。操作系统就会把 CPU 交给总优先级最高的这个进程。当进程执行完毕或者自己主动挂起后，操作系统就会重新计算一 次所有进程的总优先级，然后再挑一个优先级最高的把 CPU 控制权交给他。<br><br>Sleep函数就是告诉操作系统“在未来的多少毫秒内我不参与CPU竞争”。<br><br>对于第一个问题，答案是：不一定。因为你只是告诉操作系统：在未来的1000毫秒内我不想再参与到CPU竞争。那么1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束；况且，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。<br><br>与此相似的，Thread有个Resume函数，是用来唤醒挂起的线程的。好像上面所说的一样，这个函数只是“告诉操作系统我从现在起开始参与CPU竞争了”，这个函数的调用并不能马上使得这个线程获得CPU控制权。<br><br>对于第二个问题，答案是：有，而且区别很明显。Thread.Sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”。竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。这也是我们在大循环里面经常会写一句Thread.Sleep(0) ，因为这样就给了其他线程比如Paint线程获得CPU控制权的权力，这样界面就不会假死在那里。<br><br>另外，虽然上面提到说“除非它自己放弃使用 CPU ，否则将完全霸占 CPU”，但这个行为仍然是受到制约的——操作系统会监控你霸占CPU的情况，如果发现某个线程长时间霸占CPU，会强制使这个线程挂起，因此在实际上不会出现“一个线程一直霸占着 CPU 不放”的情况。至于我们的大循环造成程序假死，并不是因为这个线程一直在霸占着CPU。实际上在这段时间操作系统已经进行过多次CPU竞争了，只不过其他线程在获得CPU控制权之后很短时间内马上就退出了，于是就又轮到了这个线程继续执行循环，于是就又用了很久才被操作系统强制挂起。。。因此反应到界面上，看起来就好像这个线程一直在霸占着CPU一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;我们可能经常会用到 Thread.Sleep 函数来吧使线程挂起一段时间。那么你有没有正确的理解这个函数的用法呢？&lt;br&gt;&lt;/p&gt;
&lt;h6 id=&quot;思考下面这两个问题：&quot;&gt;&lt;a href=&quot;#思考下面这两个问题：&quot; class=&quot;headerlink&quot; title=&quot;思考下面这两个问题：&quot;&gt;&lt;/a&gt;思考下面这两个问题：&lt;br&gt;&lt;/h6&gt;&lt;p&gt;假设现在是 2020-05-24 12:00:00.000，如果我调用一下 Thread.Sleep(1000) ，在 2020-05-24 12:00:01.000 的时候，这个线程会不会被唤醒？&lt;br&gt;&lt;br&gt;某人的代码中用了一句看似莫明其妙的话：Thread.Sleep(0) 。&lt;br&gt;&lt;br&gt;既然是 Sleep 0 毫秒，那么他跟去掉这句代码相比，有啥区别么？&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter常用命令行（持续更新）</title>
    <link href="https://github.com/DJoeyZhang/archives/148810a7.html"/>
    <id>https://github.com/DJoeyZhang/archives/148810a7.html</id>
    <published>2020-04-13T02:05:27.000Z</published>
    <updated>2020-04-13T10:14:08.666Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些flutter开发遇到的问题和一些常用的flutter命令行，方便调试。<br><a id="more"></a></p><p>一、<br><br>flutter    列出所有的命令<br><br>flutter help    查看具体命令的帮助信息<br><br>flutter doctor    查看是否还需要安装其它依赖<br><br>flutter doctor -v    查看详细信息<br><br>flutter channel    查看 Flutter SDK 所有分支<br><br>flutter channel stable    切换分支<br><br>flutter upgrade    升级 Flutter SDK（此命令会同时更新 Flutter SDK 和你的 Flutter 项目依赖包）<br><br>flutter packages get    获取项目所有的依赖包（只更新项目依赖包，不包括 Flutter SDK）<br><br>flutter packages upgrade    获取项目所有依赖包的最新版本（只更新项目依赖包，不包括 Flutter SDK）<br><br>flutter analyze    分析项目代码<br><br>flutter build apk    <br><br>flutter build ios    <br></p><p>二、<br><br>查看Flutter版本<br><br>查看当前版本<br><br>flutter  –version<br><br>查看所有版本<br><br>flutter version<br><br>打印所有命令行用法信息 <br><br>flutter  -h或者flutter  –help<br><br>分析项目的Dart代码。<br><br>flutter  analyze<br><br>Flutter构建命令。<br><br>flutter  build<br><br>列表或开关Flutter通道。<br><br>flutter channel<br><br>删除构建/目录。<br><br>flutter  clean<br><br>配置Flutter设置。<br><br>flutter config<br><br>创建一个新的Flutter项目。<br><br>flutter  create<br><br>列出所有连接的设备。 <br><br>flutter  devices<br><br>展示了有关安装工具的信息。<br><br>flutter doctor<br><br>为当前项目运行Flutter驱动程序测试。<br><br>flutter drive<br><br>格式一个或多个Dart文件。<br><br>flutter format<br><br>在Fuchsia上进行热重载。<br><br>flutter  fuchsia_reload<br><br>显示帮助信息的Flutter。<br><br>flutter help<br><br>在附加设备上安装Flutter应用程序。<br><br>flutter install<br><br>显示用于运行Flutter应用程序的日志输出。<br><br> flutter logs<br><br>命令用于管理Flutter包。<br><br>flutter packages<br><br>填充了Flutter工具的二进制工件缓存。<br><br>flutter  precache<br><br>在附加设备上运行你的Flutter应用程序。<br><br>flutter  run<br><br>从一个连接的设备截图。<br><br>flutter screenshot<br><br>停止在附加设备上的Flutter应用。<br><br>flutter stop<br><br>对当前项目的Flutter单元测试。<br><br>flutter test<br><br>开始并停止跟踪运行的Flutter应用程序。<br><br>flutter trace<br><br>升级你的Flutter副本。<br><br>flutter upgrade<br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些flutter开发遇到的问题和一些常用的flutter命令行，方便调试。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记一些工具命令行（持续更新）</title>
    <link href="https://github.com/DJoeyZhang/archives/6f45ff58.html"/>
    <id>https://github.com/DJoeyZhang/archives/6f45ff58.html</id>
    <published>2020-03-26T06:53:48.000Z</published>
    <updated>2020-10-14T02:54:56.904Z</updated>
    
    <content type="html"><![CDATA[<h6 id="一、查看本地keystore文件（前提是有keystore的密码）"><a href="#一、查看本地keystore文件（前提是有keystore的密码）" class="headerlink" title="一、查看本地keystore文件（前提是有keystore的密码）"></a>一、查看本地keystore文件（前提是有keystore的密码）</h6><p>命令：keytool -list -v -keystore 目标文件路径<br></p><h6 id="二、查看三方应用或是系统应用签名"><a href="#二、查看三方应用或是系统应用签名" class="headerlink" title="二、查看三方应用或是系统应用签名"></a>二、查看三方应用或是系统应用签名</h6><p>右键apk解压，目标文件是META-INF文件夹中的CERT.RSA文件，通过命令keytool.exe命令查看证书信息。可以查看签名的MD5、SHA1、SHA256值及签名算法<br><br>命令：keytool -printcert -file 目标文件路径。</p><h6 id="三、内存检查命令"><a href="#三、内存检查命令" class="headerlink" title="三、内存检查命令:"></a>三、内存检查命令:</h6><p>cd /Users/joey/Library/Android/sdk/platform-tools</p><p>./hprof-conv -z /Users/joey/Desktop/memory/memory-20200819T180839.hprof /Users/joey/Desktop/me.hprof</p><h6 id="四、后台启动-jar"><a href="#四、后台启动-jar" class="headerlink" title="四、后台启动.jar"></a>四、后台启动.jar</h6><p>nohup java -jar spring-boot01-1.0-SNAPSHOT.jar &gt; log.file 2&gt;&amp;1 &amp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;一、查看本地keystore文件（前提是有keystore的密码）&quot;&gt;&lt;a href=&quot;#一、查看本地keystore文件（前提是有keystore的密码）&quot; class=&quot;headerlink&quot; title=&quot;一、查看本地keystore文件（前提是有keyst
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记录一些不错的博文(持续更新)</title>
    <link href="https://github.com/DJoeyZhang/archives/d68ca116.html"/>
    <id>https://github.com/DJoeyZhang/archives/d68ca116.html</id>
    <published>2020-03-07T15:06:00.000Z</published>
    <updated>2020-09-08T08:29:37.541Z</updated>
    
    <content type="html"><![CDATA[<p>博文而强识，温故而知新。这里记录一些平时看到的不错的文章。<br><br><a id="more"></a></p><p>1、关于Android Sqlite操作的文章，介绍的是Google官方的ROOM库，最近正好在做一个通讯录的需求用到。<br><br>Blog:<a href="https://www.jianshu.com/p/72c8efc3ad87" target="_blank" rel="noopener">https://www.jianshu.com/p/72c8efc3ad87</a><br>github:<a href="https://github.com/HoldMyOwn/RoomDemo">https://github.com/HoldMyOwn/RoomDemo</a><br>ROOM官方：<a href="https://developer.android.google.cn/jetpack/androidx/releases/room" target="_blank" rel="noopener">https://developer.android.google.cn/jetpack/androidx/releases/room</a></p><p>2、关于android应用静默升级，差分包前后端部署实现Blog:<a href="https://www.jianshu.com/p/058fd24bb2da" target="_blank" rel="noopener">https://www.jianshu.com/p/058fd24bb2da</a><br>github:<a href="https://github.com/itlwy/AppSmartUpdate">https://github.com/itlwy/AppSmartUpdate</a></p><p>3、关于OKhttp拦截器搭配retrofit使用<br>BLOG:<a href="https://www.jianshu.com/p/62ab11ddacc8" target="_blank" rel="noopener">https://www.jianshu.com/p/62ab11ddacc8</a></p><p>4、关于Room使用多表查询，建立关系型数据库<br><a href="https://www.jianshu.com/p/c7517ea16d1f" target="_blank" rel="noopener">https://www.jianshu.com/p/c7517ea16d1f</a></p><p>5、关于package.json中依赖版本配置:<br><a href="https://www.jianshu.com/p/e5959bf56844" target="_blank" rel="noopener">https://www.jianshu.com/p/e5959bf56844</a></p><p>6、关于HomeBrew源切换<br><a href="https://www.cnblogs.com/tulintao/p/11134877.html" target="_blank" rel="noopener">https://www.cnblogs.com/tulintao/p/11134877.html</a></p><p>7、关于kotlin携程的阐述<br><a href="https://blog.mindorks.com/mastering-kotlin-coroutines-in-android-step-by-step-guide" target="_blank" rel="noopener">https://blog.mindorks.com/mastering-kotlin-coroutines-in-android-step-by-step-guide</a></p><p>8、一个不错的博主，关于后端技术的博文:<br><a href="https://www.cnblogs.com/keeya/category/1255597.html" target="_blank" rel="noopener">https://www.cnblogs.com/keeya/category/1255597.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博文而强识，温故而知新。这里记录一些平时看到的不错的文章。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://github.com/DJoeyZhang/tags/android/"/>
    
      <category term="tools" scheme="https://github.com/DJoeyZhang/tags/tools/"/>
    
  </entry>
  
</feed>
